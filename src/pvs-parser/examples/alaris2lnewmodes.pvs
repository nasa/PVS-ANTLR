%%
% @module alaris2lnewmodes.pvs
% @author Michael Harrison and Paolo Masci (QMUL and Newcastle University)
% @date April 2015
% @description Theory associated with the interface to the Alaris GP
%              Maximum infusion rate, maximum and minimum vtbi, timeouts, battery maximum and minimums are parameterised
%              Further constraints minimum infusion must be less than or equal to maximum infusion
%              shorttimeout must be less than timeout (two stage timeout showing different error messages)
%              Maximum time must exceed time out
%              Maximum battery time plus one must be less than maximum time
%              Battery time minimum must be less than battery time maximum
%%

alaris_th [
   maxrate  : posnat,
   maxinfuse: posnat, 
   infusemin: { infusemin: posreal | infusemin <= maxinfuse },
   timeout  : posnat,
   shorttimeout : {shorttimeout: posnat | shorttimeout < timeout},
   maxtime  : { maxtime: posnat | maxtime > timeout AND maxtime >= maxinfuse },
   bat_max : {bat_max: posnat | bat_max+1 < maxtime},
   bat_min: {bat_min: posnat | bat_min < bat_max}
]: THEORY
 BEGIN
  IMPORTING pump_th[maxrate, maxinfuse, infusemin, timeout, shorttimeout, maxtime, bat_max, bat_min]

 %%
  % @type state
  % @description The user interface state associated with the Alaris GP
  % @property {pump} device the imported state of the pump theory
  % @property {iline} topline describes the current display on the top line
  % @property {imid} middisp describes which parameters are currently visible in the middle of the display
  % @property {o_menu} optionsmenu describes the menu of options invoked by the query function
  % @property {qcurse} qcursor the current position of the options menu cursor
  % @property {abags} bagsval the infusion bags menu
  % @property {ifunctions} fndisp1, fndisp2, fndisp3 function key displays
  % @property {irates} kvorate minimum infusion rate to keep vein open
  % @property {boolean} runlight, pauselight, ac_light, battery_light lights switched on or off
  % @property {emodes} entrymode the current entry mode
  % @property {boolean} rlock true if infusion rate locked
  % @property {boolean} rdisabled true if the means to lock or unlock the infusion rate is disabled
  % @property {ivols} newvtbi temporary value of vtbi (used when updating the value)
  % @property {irates} newrate temporary value of infusion rate (used when updating the value)
  % @property {itimes} newtime temporary value of time (used when updating the value)
  % @property {presstime} pressed how long has a chevron key been pressed (used to decide accelerator)
  % @property {steprate} current_sr current step used by chevron key use in rate entry mode
  % @property {stepvol} current_sv current step used by chevron key use in vtbi entry mode
  % @property {steptime} current_st current step used by chevron key use in time entry mode
  % @property {chev_buttons} which_press which chevron key is currently being pressed
  %%
  
state: TYPE = [#
    device : pump,
    topline: iline, % [vis]
    middisp: imid,  % [vis]
    optionsmenu: o_menu,
    bagscursor: ibagscursor, % [vis]
    qcursor: qcurse, % [vis]
    bagsval: abags, % [vis]
    fndisp1: ifunctions, % [vis]
    fndisp2: ifunctions, % [vis]
    fndisp3: ifunctions, % [vis]
    runlight: boolean, % [vis]
    pauselight: boolean, % [vis]
    ac_light: boolean, % [vis]
    battery_light: boolean,
    entrymode: emodes,
    rlock: boolean,
    rdisabled: boolean,
    newvtbi: ivols,
    newrate: irates,
    newtime: itimes,
% for the new treatment of chevron keys
    pressed: presstime,
    current_sr: steprate,
    current_sv: stepvol,
    current_st: steptime,
    which_press: chev_buttons
  #] 
%%
% @description The following functions are utility functions that decrement, trim or give ceilings for standard parameters
%%

decrement(t: presstime, n: delta): presstime =
     IF t-n>=0 THEN t-n ELSE t ENDIF
trim_rate(x: real): irates = IF x>maxrate THEN maxrate ELSIF x<0 THEN 0 ELSE x ENDIF
trim_vtbi(x: real): ivols = IF x>maxinfuse THEN maxinfuse ELSIF x<0 THEN 0 ELSE x ENDIF
trim_time(x: real): itimes = IF x>maxtime THEN maxtime ELSIF x<0 THEN 0 ELSE x ENDIF

ceil_rate(x: irates): irates = ceiling(x)
ceil_vtbi(x: ivols): ivols = ceiling(x)
ceil_time(x: itimes): itimes = ceiling(x)

%%
  % @function init?
  % @description predicate that initialises the state
  % @param {state} st The state of the system
  % @returns {bool} True when state initialised
  % @memberof module: alaris_th
  %%

init?(st: state): bool =
    init?(st`device) and 
    topline(st) = dispblank and
    middisp(st)(drate) = FALSE and
    middisp(st)(dvtbi) = FALSE and
    middisp(st)(dtime) = FALSE and
    middisp(st)(dvol) = FALSE and
    middisp(st)(dbags) = FALSE and
    middisp(st)(dkvorate) = FALSE and
    middisp(st)(dquery) = FALSE and
    middisp(st)(dnewvtbi) = FALSE and
    middisp(st)(dnewrate) = FALSE and
    middisp(st)(dnewtime) = FALSE and
    bagscursor(st) = midbag and
    qcursor(st) = dlock and
    bagsval(st)(0) = 0 and
    bagsval(st)(1) = 50 and
    bagsval(st)(2) = 100 and
    bagsval(st)(3) = 200 and
    bagsval(st)(4) = 250 and
    bagsval(st)(5) = 500 and
    bagsval(st)(6) = 1000 and
    bagsval(st)(7) = 1500 and
    bagsval(st)(8) = 2000 and
    bagsval(st)(9) = 3000 and
    fndisp1(st) = fnull and
    fndisp2(st) = fnull and
    fndisp3(st) = fnull and
    runlight(st) = FALSE and
    pauselight(st) = FALSE and
    ac_light(st) = FALSE and
    battery_light(st) = FALSE and
    entrymode(st) = nullmode and
    rlock(st) = false and
    rdisabled(st) = false and
    newvtbi(st) = 0 and % these don't need to be initialised
    newrate(st) = 0 and
    newtime(st) = 0 and
    which_press(st) = nob and
    current_sv(st) = small_step and
    current_sr(st) = small_step and
    current_st(st) = small_step and
    pressed(st) = maxpress

% actions relating to the pressing of chevron keys
%%
  % @function no_button_down
  % @description predicate which is true if the chevron key is not pressed (normal state of the alaris)
  % @param {state} st
  % @returns {bool} true if the pressed value is maximum (decrements on each press) and no button indicated as pressed (nob)
  % @memberof module: alaris_th
%%
 no_button_down(st: state): bool =
    which_press(st) = nob AND pressed(st) = maxpress
 
%%
  % @function release_key
  % @description chevron key is released and return to no button press state
  % @param {state} st
  % @returns {state} maxpress is decrement when the chevron key is pressed
  % @memberof module: alaris_th
%%
 release_key(st:state): state = 
    st WITH [ which_press := nob,
              current_sr := small_step,
              current_sv := small_step,
              current_st := small_step,
              pressed := maxpress ]

%%
  % @function dispblank?
  % @description predicate which is true if top line is blank and the device is not powered on
  % @param {state} st
  % @returns {bool} 
  % @memberof module: alaris_th
%%

dispblank?(st: state): bool = (st`topline = dispblank) AND NOT device(st)`powered_on?

%%
  % @function per_switch
  % @description switch is permitted if device on, no chevron key is depressed, connected to the battery, or connected to the mains
  % @param {state} st
  % @returns {bool} 
  % @memberof module: alaris_th
%%
per_switch(st: state): boolean =
         device(st)`powered_on? AND no_button_down(st) AND
           ((device(st)`ac_connect AND ac_light(st) AND NOT(battery_light(st)))
	   OR (NOT device(st)`ac_connect AND NOT ac_light(st) AND
	             battery_light(st)))
	       

%%
  % @function switch
  % @description switches from mains to battery or battery to mains
  % @param {state} st
  % @returns {state} three cases: connected to the mains, not connected to the mains and showing battery low, not connected to the mains and no battery warning
  % @memberof module: alaris_th
%%

%%
  % @function switch_from_battery_low
  % @description switches to mains: sets top line depending on infusing status, 
  % @description shows the relevant parameters in the middle display and function keys, and specifies entry mode
  % @description invokes the device level change to mains
  % @param {state} st
  % @returns {state} 
  % @memberof module: alaris_th
%%

switch_from_battery_low(st: state): state = 
      st WITH [ topline := COND device(st)`infusing? AND NOT device(st)`kvoflag -> infusing,
                                device(st)`infusing? AND device(st)`kvoflag -> dispkvo,
                                NOT device(st)`infusing? & device(st)`infusionrate = 0
                                        -> setrate,
                                ELSE -> holding
                           ENDCOND,
                middisp := 
                  COND NOT device(st)`infusing? -> 
                           LAMBDA(x: imid_type):
		            COND (x = drate) OR (x = dvol)  -> TRUE,
			         (x = dvtbi) OR (x = dtime)  -> device(st)`vtbi /= 0,
			         ELSE -> FALSE ENDCOND,
                        ELSE ->
                          LAMBDA(x: imid_type):
                           COND x = drate -> NOT device(st)`kvoflag,
                                x = dkvorate -> device(st)`kvoflag,
                                (x = dvtbi) OR (x = dvol) OR (x = dtime) -> TRUE,
				ELSE -> FALSE ENDCOND
                        ENDCOND,
                fndisp1 := fvol,
		fndisp2 := COND device(st)`infusing? AND device(st)`kvoflag -> fnull,
                           ELSE -> fvtbi ENDCOND,
                fndisp3 := fnull,
		entrymode  := COND NOT device(st)`infusing? -> rmode,
                                   ELSE -> infusemode
                              ENDCOND,
                device := mains_switch(st`device),
                ac_light := TRUE,
                battery_light := FALSE
	        ]

%%
  % @function switch_battery_low
  % @description switches to to battery, because the battery is low shows message in top line
  % @description otherwise the display is blank 
  % @description invokes the device level change to battery
  % @param {state} st
  % @returns {state} 
  % @memberof module: alaris_th
%%

switch_battery_low(st: state): state =
       st WITH [ topline := batterylow,
                middisp := LAMBDA(x: imid_type): FALSE,
                fndisp1 := fnull,
                fndisp2 := fnull,
		fndisp3 := fcancel,
              	entrymode   := nullmode,
                device := mains_switch(st`device),
                ac_light := FALSE,
                battery_light := TRUE ]

%%
  % @function switch
  % @description switches from mains to battery or battery to mains
  % @param {per_switch} st
  % @returns {state} shows cases
  % @memberof module: alaris_th
%%

switch(st: (per_switch)): state =
     COND
       device(st)`ac_connect -> switch_battery_low(st),
       NOT device(st)`ac_connect & (topline(st) = batterylow) ->
                    switch_from_battery_low(st),
       ELSE -> st WITH [device := mains_switch(st`device),
                    ac_light := TRUE,
                    battery_light := FALSE]
      ENDCOND

%%
  % @function per_fit_set
  % @description fit_set is permitted if device on, no chevron key is depressed
  % @param {per_fit_set} st
  % @returns {bool} 
  % @memberof module: alaris_th
%%

per_fit_set(st: state): boolean =
      device(st)`powered_on? AND no_button_down(st)

%%
  % @function fit_set
  % @description fits the giving set, only if not fitted and paused
  % @param {state} st
  % @returns {state} invokes pump level fit function, shows holding or setrate (if infusion rate is zero) and resets time since user action
  % @memberof module: alaris_th
%%

fit_to_hold(st: state): state =
   st WITH [ topline := COND device(st)`infusionrate = 0 -> setrate,
                           ELSE -> holding ENDCOND,
             middisp := LAMBDA(x: imid_type): (x = drate) OR
	                             ( x = dvol),
             fndisp1 := fvol,
	     fndisp2 := fvtbi,
             fndisp3 := fnull,
	     entrymode  := rmode,
	     device  := resetElapsed(device(st))]



fit_set(st: (per_fit_set)): state =
      COND
        topline(st) = setnotfitted & NOT device(st)`infusing? -> 
                    fit_to_hold(st),
        ELSE -> st
      ENDCOND WITH [ device := connect_set(st`device)]

%%
  % @function per_on
  % @description on is permitted if device off and top line display blank, device on and top line display not blank
  % @param {state} st
  % @returns {bool} 
  % @memberof module: alaris_th
%%
 per_on(st:state): bool =
    (NOT device(st)`powered_on? AND topline(st) = dispblank) OR
    (device(st)`powered_on? AND topline(st) /= dispblank)

%%
  % @function on
  % @description switches the alaris on or off
  % @param {state} st
  % @returns {state} two functions relating to the two permitted conditions
  % @memberof module: alaris_th
%%

%%
  % @function on_case_infusionstatusblank
  % @description on from power off
  % @param {state} st
  % @returns {state} shows the stored pump parameters and sets up the initial display which invites to clear the parameters
  % @memberof module: alaris_th
%%
   
  on_case_infusionstatusblank(st: state): state =
         st WITH [ device := on(st`device),
                   topline := COND 
                               device(st)`vtbi /= 0 OR device(st)`infusionrate /= 0 
                                    OR device(st)`time /= 0 -> clearsetup,
                               ELSE -> setrate
                              ENDCOND,
                   middisp := LAMBDA(x: imid_type): 
                                COND x = drate -> TRUE,
                                     x = dvtbi -> device(st)`vtbi /= 0,
                                     x = dtime -> (device(st)`vtbi /= 0) OR
                                                  (device(st)`infusionrate /= 0),
                                     x = dvol  -> TRUE,
                                    ELSE -> FALSE ENDCOND,
                   fndisp1 := COND
                               device(st)`vtbi /= 0 OR device(st)`infusionrate /= 0 
                                    OR device(st)`time /= 0 -> fclear,
                               ELSE -> fvol
                              ENDCOND,
                   fndisp2 := COND
                                device(st)`vtbi /= 0 OR device(st)`infusionrate /= 0
                                     OR device(st)`time /= 0 -> fnull,
                                ELSE -> fvtbi
                              ENDCOND,
                   fndisp3 := COND
                                device(st)`vtbi /= 0 OR device(st)`infusionrate /= 0 
                                     OR device(st)`time /= 0 -> fkeep,
                                ELSE -> fnull
                              ENDCOND,
                   entrymode := COND
                                  device(st)`vtbi /= 0 OR device(st)`infusionrate /= 0 
                                      OR device(st)`time /= 0 -> nullmode,
                                  ELSE -> rmode
                                ENDCOND,
                   rdisabled := FALSE,
                   ac_light := device(st)`ac_connect,
                   battery_light := NOT device(st)`ac_connect,
                   pauselight := TRUE,
                   runlight := FALSE,
                   which_press := nob,
                   current_sv := small_step,
                   current_sr := small_step,
                   current_st := small_step,
                   pressed := maxpress ]

%%
  % @function on_case_infusionstatusNOTblank
  % @description off from power on
  % @param {state} st
  % @returns {state} clears the display
  % @memberof module: alaris_th
%%

  on_case_infusionstatusNOTblank(st: state): state = 
     st WITH [
        device := on(st`device),
        topline := dispblank,
        middisp := LAMBDA(x: imid_type): FALSE,
        bagscursor := midbag,
        entrymode  := nullmode,
        ac_light := FALSE,
        battery_light := FALSE,
        pauselight := FALSE,
        runlight   := FALSE,
        fndisp1    := fnull,
        fndisp2    := fnull,
        fndisp3    := fnull ]
%%
  % @function on
  % @description deals with the two permitted cases
  % @param {per_on} st
  % @returns {state} 
  % @memberof module: alaris_th
%%

  on(st: (per_on)): state =
   COND 
     NOT device(st)`powered_on? AND topline(st) = dispblank -> on_case_infusionstatusblank(st),
     device(st)`powered_on? AND topline(st) /= dispblank-> on_case_infusionstatusNOTblank(st)
   ENDCOND

      
%%
  % @function per_run
  % @description run is permitted if device start is permitted, the top line shows holding, entry mode is rmode and the chevron keys are not depressed
  % @param {state} st
  % @returns {bool} 
  % @memberof module: alaris_th
%%

  per_run(st: state): bool = per_start(st`device) AND 
                              topline(st) = holding AND 
                              entrymode(st) = rmode AND no_button_down(st)
                             
%%
  % @function run
  % @description deals with the five permitted cases
  % @param {state} st
  % @returns {state} 
  % @memberof module: alaris_th
%%

%%
  % @function run_cond_NZ
  % @description uncomplicated run, device paused, no locks, no zero parameters
  % @param {state} st
  % @returns {state} sets the display for infusing, and starts the pump device
  % @memberof module: alaris_th
%%

  run_cond_NZ(st: {st: state | per_run(st)}): state =
    st WITH [ device := start(st`device),
              topline := infusing,
              middisp := LAMBDA(x: imid_type): (x = drate) OR (x = dvtbi) OR (x = dvol) OR (x = dtime),
              fndisp1 := fvol,
              fndisp2 := fvtbi,
              fndisp3 := fnull,
              entrymode  := infusemode,
              runlight := TRUE,
              pauselight := FALSE ]

%%
  % @function run_check_rlock
  % @description uncomplicated run, invites to the lock infusion rate (to prevent future tampering)
  % @param {per_run(st)} st
  % @returns {state} sets the display with function keys for yes / no response to top line question
  % @memberof module: alaris_th
%%

  run_check_rlock(st: (per_run)): state =
     st WITH [topline := lockrate,
              middisp := LAMBDA (x: imid_type): FALSE,
              fndisp1 := fyes,
              fndisp2 := fnull,
              fndisp3 := fno,
              entrymode := nullmode]

%%
  % @function run_cond_vtbi0_kvoflag
  % @description run when vtbi is zero and kvo mode
  % @param {state} st
  % @returns {state} shows vtbi done in top line, starts the pump device, offers possibility of cancel (key3)
  % @memberof module: alaris_th
%%

  run_cond_vtbi0_kvoflag(st: {st: state | per_run(st)}): state = 
     st WITH [ device := start(st`device),
               topline := vtbidone,
               middisp := LAMBDA(x: imid_type): FALSE,
               fndisp1 := fnull,
               fndisp2 := fnull,
               fndisp3 := fcancel,
               runlight := true,
               pauselight := false,
               entrymode  := nullmode]

%%
  % @function run_vtbi0_NOTkvoflag
  % @description run when vtbi is zero and kvoflag not set
  % @param {state} st
  % @returns {state} invites to set vtbi (top line), and invokes pump device start which sets kvoflag
  % @memberof module: alaris_th
%%

  run_cond_vtbi0_NOTkvoflag(st: {st: state | per_run(st)}): state =
       st WITH [ device := start(st`device),
                 topline := setvtbi,
                 middisp := LAMBDA(x: imid_type): FALSE,
                 fndisp1 := fnull,
                 fndisp2 := fvtbi,
                 fndisp3 := fcancel,
                 entrymode  := nullmode]

 %%
  % @function run_cond_setnotfitted
  % @description attempt to run when the giving set has not been fitted
  % @param {state} st
  % @returns {state} indicates that the set has not been fitted (top line)
  % @memberof module: alaris_th
%% 

  run_cond_setnotfitted(st: {st: state | per_run(st)}): state =
       st WITH [ topline := setnotfitted,
                 middisp := LAMBDA(x: imid_type): FALSE,
                 fndisp1 := fnull,
                 fndisp2 := fnull,
                 fndisp3 := fcancel,
                 entrymode  := nullmode]

%%
  % @function run
  % @description checks for the five permitted cases
  % @param {per_run(st)} st
  % @returns {state} 
  % @memberof module: alaris_th
%%

  run(st: {st: state | per_run(st)}): state =
      COND device(st)`vtbi /= 0	& 
                device(st)`infusionrate /= 0 & rlock(st) & 
                device(st)`set_fitted	        
                     -> run_cond_NZ(st),
           device(st)`vtbi /= 0	& 
                device(st)`infusionrate /= 0 & NOT rlock(st) & 
                 device(st)`set_fitted	        
                     -> run_check_rlock(st),
           device(st)`vtbi = 0 & device(st)`kvoflag & 
                  device(st)`set_fitted     -> run_cond_vtbi0_kvoflag(st),
           device(st)`vtbi = 0 & NOT device(st)`kvoflag & 
                 device(st)`set_fitted -> run_cond_vtbi0_NOTkvoflag(st),
           NOT device(st)`set_fitted -> run_cond_setnotfitted(st)
      ENDCOND
  
%%
  % @function per_pause
  % @description pause is permitted if pause is perimitted in the pump, and a range of top lines associated with infusing are visible
  % @param {state} st
  % @returns {bool} 
  % @memberof module: alaris_th
%%

   per_pause(st: state): bool =
       per_pause(st`device) AND
      ((((topline(st) = infusing) OR (topline(st) = dispkvo)) & entrymode(st) = infusemode) OR
       ((topline(st) = dispvtbi) & ((entrymode(st) = vtmode) OR (entrymode(st) = bagmode))) OR
       (topline(st) = volume & entrymode(st) = nullmode) OR 
       (topline(st) = locked & entrymode(st) = infusemode))

%%
  % @function pause
  % @description pauses the pump device and shows the top line of holding, the device becomes paused
  % @param {per_pause(st)} st
  % @returns {state} 
  % @memberof module: alaris_th
%%
   pause(st: {st: state | per_pause(st)}): state =
       st
         WITH [device := pause(st`device),
               topline := holding,
               middisp
                 := LAMBDA (x: imid_type):
                      COND (x = drate) OR (x = dvol) -> TRUE,
                           (x = dvtbi) OR (x = dtime) -> (device(st)`vtbi /= 0),
                           ELSE -> FALSE
                      ENDCOND,
               fndisp1 := fvol,
               fndisp2 := fvtbi,
               fndisp3 := fnull,
               entrymode := rmode,
               pauselight := TRUE,
               runlight := FALSE]

%%
  % @function per_query
  % @description query is permitted if the device is paused and the top line shows holding or set rate, or device infusing and shows top line of infusing
  % @param {state} st
  % @returns {bool} 
  % @memberof module: alaris_th
%%
  per_query(st: state): bool = 
         ((((topline(st) = holding OR topline(st) = setrate) & entrymode(st) = rmode) & NOT device(st)`infusing?) OR
                                ((topline(st) = infusing & entrymode(st) = infusemode) & device(st)`infusing? & 
                                  NOT device(st)`kvoflag)) AND 
                                device(st)`powered_on? AND no_button_down(st)

%%
  % @function query
  % @description  shows the options menu, the entries in the menu vary depending on whether the infusion rate has been locked or disabled
  % @param {per_query(st)} st
  % @returns {state} sets the time since last action to zero
  % @memberof module: alaris_th
%%

  query(st: {st: state | per_query(st)}): state = 
          st WITH [ qcursor := 0,
                    topline := options,
                    middisp := LAMBDA(x: imid_type): x = dquery,
		    fndisp1 := fok,
          	    fndisp2 := fnull,
		    fndisp3 := fquit,
		    entrymode   := qmode,
                    optionsmenu := 
                      COND
                        device(st)`infusing? AND NOT rdisabled(st) AND 
                        rlock(st)->
                         LAMBDA(x: qcurse):
                           COND
                             x=0 -> ratelock,
                             x=1 -> dosingsumm,
                             x=2 -> adjalarm,
                             x=3 -> pumpdetails,
                             ELSE -> optionblank
                           ENDCOND,
                        device(st)`infusing? AND NOT rdisabled(st) AND
                        NOT rlock(st) ->
                         LAMBDA(x: qcurse):
                           COND
                             x=0 -> rateunlock,
                             x=1 -> dosingsumm,
                             x=2 -> adjalarm,
                             x=3 -> pumpdetails,
                             ELSE -> optionblank
                           ENDCOND, 
                         device(st)`infusing? AND rdisabled(st) ->
                         LAMBDA(x: qcurse):
                           COND
                             x=0 -> dosingsumm,
                             x=1 -> adjalarm,
                             x=2 -> pumpdetails,
                             ELSE -> optionblank
                           ENDCOND,
                          NOT device(st)`infusing? AND NOT rdisabled(st) AND
                          NOT rlock(st) ->
                         LAMBDA(x: qcurse):
                           COND
                             x=0 -> ratelock,
                             x=1 -> dosingsumm,
                             x=2 -> infusionsetup,
                             x=3 -> setvtbiovertime,
                             x=4 -> adjalarm,
                             x=5 -> disableratelock,
                             x=6 -> pumpdetails
                           ENDCOND,
                          NOT device(st)`infusing? AND NOT rdisabled(st) AND
                          rlock(st) ->
                         LAMBDA(x: qcurse):
                           COND
                             x=0 -> rateunlock,
                             x=1 -> dosingsumm,
                             x=2 -> infusionsetup,
                             x=3 -> setvtbiovertime,
                             x=4 -> adjalarm,
                             x=5 -> disableratelock,
                             x=6 -> pumpdetails
                           ENDCOND,
                          NOT device(st)`infusing? AND rdisabled(st)  ->
                         LAMBDA(x: qcurse):
                           COND
                             x=0 -> dosingsumm,
                             x=1 -> infusionsetup,
                             x=2 -> setvtbiovertime,
                             x=3 -> adjalarm,
                             x=4 -> enableratelock,
                             x=5 -> pumpdetails,
                             ELSE -> optionblank
                           ENDCOND
                      ENDCOND,
                    device  := resetElapsed(device(st)) ]


%%
  % @function per_tick
  % @description tick is permitted if tick is perimitted in the pump, and a range of top lines associated with holding and infusing are visible
  % @param {state} st
  % @returns {bool} 
  % @memberof module: alaris_th
%%
  per_tick(st: state): bool =
      per_tick(device(st)) AND
        ((NOT device(st)`infusing? AND no_button_down(st) AND
           (((entrymode(st) = rmode) & 
             (((topline(st) = holding OR topline(st) = setrate) & middisp(st)(dvol)) OR 
              (topline(st) = locked & rlock(st)))) OR
             (middisp(st)(dnewvtbi) & middisp(st)(dnewtime) & middisp(st)(dnewrate) &
               ((entrymode(st) = vttmode) OR (entrymode(st) = ttmode)) & 
                 (topline(st) = vtbitime)) OR
             (topline(st) = setvtbi AND entrymode(st) = nullmode) OR 
           ((((entrymode(st) = vtmode) & middisp(st)(dnewvtbi)) OR 
              (entrymode(st) = bagmode) OR 
              (entrymode(st) = tbagmode)) & (topline(st) = dispvtbi)) OR
           (((topline(st) = attention) OR (topline(st) = volume) OR
             (topline(st) = setnotfitted) OR 
             ((topline(st) = batterylow) AND NOT device(st)`ac_connect) OR
             (topline(st) = dispinfo)) & (entrymode(st) = nullmode)) OR
         ((entrymode(st) = qmode) & (topline(st) = options)))) OR
% infusing
         (device(st)`infusing? AND no_button_down(st) AND
               ((entrymode(st) = infusemode) & 
               (NOT device(st)`kvoflag &
               (((topline(st) = infusing) & middisp(st)(dtime) & middisp(st)(dvtbi) & 
                                            middisp(st)(drate) & middisp(st)(dvol)) OR 
               ((((entrymode(st) = vtmode) & middisp(st)(dnewvtbi))) & (topline(st) = dispvtbi)) OR
               (topline(st) = locked) OR
               ((entrymode(st) = nullmode) & ((topline(st) = volume) OR
                                        (topline(st) = dispinfo) OR (topline(st) = batterylow))) OR
               ((entrymode(st) = qmode) & (topline(st) = options)))) OR
               (device(st)`kvoflag &
                ((topline(st) = dispkvo) & middisp(st)(dtime) & middisp(st)(dkvorate) & 
                                  middisp(st)(dvol) & middisp(st)(dvtbi)) OR 
               (((topline(st) = vtbidone) OR (topline(st) = batterylow AND NOT device(st)`ac_connect)) AND (entrymode(st) = nullmode))))))
    
%%
  % @function tick
  % @description  deals with nine cases
  % @param {per_tick} st
  % @returns {state}
  % @memberof module: alaris_th
%%           

%%
  % @function tick_case_holding_volume_etc_elapseLTtimeout
  % @description  invoked when paused and elapsed time since action does not exceed time out
  % @param {per_tick} invokes pump device tick
  % @returns {state}
  % @memberof module: alaris_th
%% 

    tick_case_holding_volume_etc_elapseLTtimeout
     (st: {st: state | per_tick(device(st))}): state =
      st WITH [ device := tick(st`device)]

%%
  % @function tick_case_holding_volume_etc_elapseLTtimeoutlocked
  % @description  device shows infusion rate locked, tick will return the top line display to previous state and other relevant attributes
  % @param {per_tick} st
  % @returns {state}
  % @memberof module: alaris_th
%% 

    tick_case_holding_volume_etc_elapseLTtimeoutlocked
     (st: {st: state | per_tick(device(st))}): state =
      st WITH [ device := tick(st`device),
                topline := COND 
                             entrymode(st) = qmode -> options,
                             entrymode(st) /= qmode & 
                              device(st)`infusionrate = 0
                                  -> setrate,
                             ELSE -> holding
                           ENDCOND,
                middisp
                 := LAMBDA (x: imid_type):
                      COND (x = drate) OR (x = dvol) -> TRUE,
                           (x = dvtbi) OR (x = dtime) -> (device(st)`vtbi /= 0),
                           ELSE -> FALSE
                      ENDCOND,
               fndisp1 := COND 
                             entrymode(st) = qmode -> fok,
                             ELSE -> fvol
                           ENDCOND,
               fndisp2 := COND 
                             entrymode(st) = qmode -> fnull,
                             ELSE -> fvtbi
                           ENDCOND,
               fndisp3 := COND 
                             entrymode(st) = qmode -> fquit,
                             ELSE -> fnull
                           ENDCOND]

%%
  % @function tick
  % @description  deals with the case when holding and elapsed time since last action equals timeout
  % @param {per_tick} st
  % @returns {state} top line shows attention, otherwise screen blank apart from function key 3 enables cancel, invokes the pump device tick
  % @memberof module: alaris_th
%% 

    tick_case_holding_volume_etc_elapseEQtimeout
      (st: {st: state | per_tick(device(st))}): state = 
      st WITH [ device := tick(st`device),
                topline := attention,
                middisp := LAMBDA(x: imid_type): FALSE,
                fndisp1 := fnull,
                fndisp2 := fnull,
		fndisp3 := fcancel,
              	entrymode   := nullmode ]

%%
  % @function tick
  % @description  when the battery runs low the tick shows the battery low warning
  % @param {per_tick} st
  % @returns {state} invokes the pump device tick
  % @memberof module: alaris_th
%% 

    tick_case_battery_warning
      (st: {st: state | per_tick(device(st))}): state = 
      st WITH [ device := tick(st`device),
                topline := batterylow,
                middisp := LAMBDA(x: imid_type): FALSE,
                fndisp1 := fnull,
                fndisp2 := fnull,
		fndisp3 := fcancel,
              	entrymode   := nullmode ]

%%
  % @function tick_case_holding_volume_etc_elapsedEQshorttimeout
  % @description  deals with the case when paused at the short time out (prior to the result of the longer time out)
  % @param {per_tick} st
  % @returns {state} takes the alaris to rmode and topline holding or set-rate (if rate is zero) and pump device ticks
  % @memberof module: alaris_th
%% 

tick_case_holding_volume_etc_elapseEQshorttimeout
      (st: {st: state | per_tick(device(st))}): state = 
      LET newdevice = tick(device(st)) IN
      st WITH [ device := newdevice,
                topline := COND
                           device(st)`infusionrate = 0 -> setrate,
                           ELSE -> holding
                           ENDCOND,
                middisp := LAMBDA(x: imid_type):
 		             COND (x = drate) OR (x = dvol) -> TRUE,
			          (x = dvtbi) OR (x = dtime)  -> newdevice`vtbi /= 0,
				  ELSE -> FALSE ENDCOND,
                fndisp1 := fvol,
                fndisp2 := fvtbi,
		fndisp3 := fnull,
              	entrymode   := rmode ]

%%
  % @function tick_case_infuse_infusionrateLTvtbi
  % @description  the case that the device is infusing and infusion rate is less than VTBI
  % @param {per_tick} invokes pump device tick otherwise unchanged
  % @returns {state}
  % @memberof module: alaris_th
%% 

    tick_case_infuse_infusionrateLTvtbi(st: {st: state | per_tick(device(st))}): state =
       st WITH [device := tick(st`device)]

%%
  % @function tick_case_infuse_infusionrateLTvtbilocked
  % @description normal tick while pump infusing and infusion rate locked, and rate locked shown in previous top line
  % @param {per_tick} st
  % @returns {state} reverts to normal infusing display
  % @memberof module: alaris_th
%% 

     tick_case_infuse_infusionrateLTvtbilocked(st: {st: state | per_tick(device(st))}): state =
       st WITH [device := tick(st`device),
                topline := infusing,
                middisp := LAMBDA(x: imid_type):
                            COND x = drate -> TRUE,
                                 x = dvtbi -> TRUE,
				 x = dvol  -> TRUE,
				 x = dtime -> TRUE,
				 ELSE -> FALSE ENDCOND,
                fndisp1 := fvol,
                fndisp2 := fvtbi,
                fndisp3 := fnull,
                entrymode  := infusemode]

%%
  % @function tick_case_infuse_infusionrateEQvtbi_kvoflag
  % @description  the device is in KVO mode and infusing at minimal level
  % @param {per_tick} st
  % @returns {state} display is not affected
  % @memberof module: alaris_th
%% 

tick_case_infuse_infusionrateEQvtbi_kvoflag(st: {st: state | per_tick(device(st))}): state = 
      st WITH [device := tick(st`device)]

%%
  % @function tick_case_infuse_infusionrateEQvtbi_notkvoflag
  % @description  vtbi is exhausted and KVO not set and infusing
  % @param {per_tick} st
  % @returns {state} Displays that vtbi done in top line, invokes tick in pump device continues to infuse at KVO level - setting kvo flag
  % @memberof module: alaris_th
%% 

tick_case_infuse_infusionrateEQvtbi_notkvoflag(st: {st: state | per_tick(device(st))}): state = 
      release_key(st) WITH [ device := tick(st`device),
                topline := vtbidone,
                middisp := LAMBDA(x: imid_type): FALSE,
                fndisp1 := fnull,
                fndisp2 := fnull,
		fndisp3 := fcancel,
              	entrymode   := nullmode ]

%%
  % @function tick
  % @description  deals with nine cases depending on conditions
  % @param {per_tick} st
  % @returns {state}
  % @memberof module: alaris_th
%%    
    tick(st: (per_tick)): state =
      IF
       NOT device(st)`ac_connect AND 
               device(st)`battery <= bat_min THEN tick_case_battery_warning(st)
      ELSE
        IF NOT device(st)`infusing? THEN
           COND
            (device(st)`elapse >= timeout)
                    -> tick_case_holding_volume_etc_elapseEQtimeout(st),
            (device(st)`elapse >= shorttimeout) & 
                    (device(st)`elapse < timeout)
                    -> tick_case_holding_volume_etc_elapseEQshorttimeout(st),
            (device(st)`elapse < shorttimeout) ->
               COND
                topline(st) = locked -> 
                   tick_case_holding_volume_etc_elapseLTtimeoutlocked(st),
                topline(st) /= locked -> 
                   tick_case_holding_volume_etc_elapseLTtimeout(st)
               ENDCOND
             ENDCOND
         ELSE
          COND (device(st)`infusionrate < device(st)`vtbi) 
                    -> 
                  COND
                   topline(st) = locked -> 
                       tick_case_infuse_infusionrateLTvtbilocked(st),
                   topline(st) /= locked -> 
                        tick_case_infuse_infusionrateLTvtbi(st)
                  ENDCOND,
               (device(st)`infusionrate >= device(st)`vtbi) & 
                    NOT device(st)`kvoflag
	            -> tick_case_infuse_infusionrateEQvtbi_notkvoflag(st),
               (device(st)`infusionrate >= device(st)`vtbi) & 
                   device(st)`kvoflag
	            -> tick_case_infuse_infusionrateEQvtbi_kvoflag(st)
           ENDCOND
         ENDIF
       ENDIF

%%
  % @function per_key1
  % @description key1 is permitted in a range of conditions - these are all described and correspond to cases to follow
  % @param {state} st
  % @returns {bool} 
  % @memberof module: alaris_th
%%

  per_key1(st: state): bool = 
   device(st)`powered_on? & no_button_down(st) &
    (( NOT device(st)`infusing? &
       (((topline(st) = holding OR topline(st) = setrate) AND entrymode(st) = rmode AND 
                   fndisp1(st) = fvol) OR 
        (((topline(st) = clearsetup & fndisp1(st) = fclear & middisp(st)(dvol) & middisp(st)(drate) &
                  ((device(st)`vtbi /= 0) IMPLIES middisp(st) (dvtbi)) &
                  (((device(st)`vtbi /= 0) OR (device(st)`infusionrate /= 0)) => 
                            middisp(st)(dtime))) OR 
          (topline(st) = lockrate & fndisp1(st) = fyes & device(st)`vtbi /= 0 & device(st)`infusionrate /= 0)) & entrymode(st)=nullmode) OR
      ((topline(st) = dispvtbi) & 
           ((entrymode(st) = vtmode & fndisp1(st) = fok & middisp(st)(dnewvtbi)) OR 
            (entrymode(st) = bagmode & fndisp1(st) = fok) OR
            (entrymode(st) = tbagmode & fndisp1(st) = fok))) OR
       ((topline(st) = vtbitime) & (((entrymode(st) = vttmode) & (fndisp1(st) = fok) & 
                                        (device(st)`vtbi /= 0)) OR
                                    (entrymode(st) = ttmode)) & (fndisp1(st) = fok) & 
                                     middisp(st)(dnewrate) &
                                     middisp(st)(dnewvtbi) & middisp(st)(dnewtime)) OR
       ((topline(st) = options) & (fndisp1(st) = fok) & (entrymode(st) = qmode)))) OR
    (device(st)`infusing? & ((((topline(st) = dispkvo) OR (topline(st) = infusing)) AND (entrymode(st) = infusemode) & (fndisp1(st) = fvol)) OR ((topline(st) = dispvtbi) & 
                      ((entrymode(st) = vtmode & fndisp1(st) = fok & middisp(st)(dnewvtbi)) OR 
                        (NOT device(st)`kvoflag & fndisp1(st) = fok & entrymode(st) = bagmode))) OR
                        ((topline(st) = options) & (fndisp1(st) = fok) & (entrymode(st) = qmode) & 
                          NOT device(st)`kvoflag &
                          ((optionsmenu(st)(qcursor(st)) /= optionblank) AND
                           (optionsmenu(st)(qcursor(st)) /= setvtbiovertime) AND
                           (optionsmenu(st)(qcursor(st)) /= disableratelock) AND
                           (optionsmenu(st)(qcursor(st)) /= enableratelock))))) )


  %%
  % @function key1
  % @description  deals with fifteen cases depending on conditions
  % @param {per_key1} st
  % @returns {state}
  % @memberof module: alaris_th
%% 

%%
  % @function key1_case_clearsetup
  % @description  when top line shows clear set up
  % @param {per_key1} st
  % @returns {state} alaris pump takes rmode and shows setrate because infusion rate has been set to 0
  % @memberof module: alaris_th
%% 
  key1_case_clearsetup(st: (per_key1)):state =
     st WITH [ topline := setrate,
      	       middisp := LAMBDA(x: imid_type): (x = drate) OR (x = dvol),
               device := reset(device(st)),
               fndisp1 := fvol,
	       fndisp2 := fvtbi,
	       fndisp3 := fnull,
               entrymode  := rmode ]
%%
  % @function key1_case_infuselocked
  % @description  when trying to start an infusion and request to lock rate
  % @param {per_key1} st
  % @returns {state} if permitted then starts device, sets rlock to true, and starts infusing with appropriate displays
  % @memberof module: alaris_th
%% 
  key1_case_infuselocked(st: (per_key1)): state =
       st WITH [ device := 
                  IF per_start(st`device) THEN start(st`device)
                  ELSE st`device
                  ENDIF,
              rlock := TRUE,
              topline := infusing,
              middisp := LAMBDA(x: imid_type):
                           COND x = drate -> TRUE,
                                x = dvtbi -> TRUE,
				x = dvol  -> TRUE,
				x = dtime -> TRUE,
				ELSE -> FALSE ENDCOND,
              fndisp1 := fvol,
              fndisp2 := fvtbi,
              fndisp3 := fnull,
              entrymode  := infusemode,
              runlight := TRUE,
              pauselight := FALSE ]

%%
  % @function key1_case_holdinginfusingdispkvo
  % @description  when top line shows keep vein open
  % @param {per_key1} st
  % @returns {state} top line shows volume, provides the option to clear the volume infused, sets elapsed time since last action to zero
  % @memberof module: alaris_th
%% 

  key1_case_holdinginfusingdispkvo(st: (per_key1)): state =
      st WITH [ topline := volume,
      	        middisp := LAMBDA(x: imid_type): x = dvol,
                device := resetElapsed(device(st)),
                fndisp1 := fnull,
		fndisp2 := fclear,
		fndisp3 := fquit,
                entrymode  := nullmode ]

%%
  % @function key1_dispvtbi_vtmode
  % @description  when in vtmode and top line shows volume to be infused
  % @param {per_key1} st
  % @returns {state} exits the mode and enters rmode or infusemode depending whether the device is infusing or not, updates pump variable vtbi with temporary value newvtbi
  % @memberof module: alaris_th
%% 

 
  key1_case_dispvtbi_vtmode(st: (per_key1)): state =
                 st WITH [ topline := COND NOT device(st)`infusing? & 
                                           device(st)`infusionrate /= 0 -> holding,
                                           NOT device(st)`infusing? & 
                                           device(st)`infusionrate = 0 -> setrate,
                                           device(st)`infusing? -> infusing
                                      ENDCOND,
                    	   entrymode := COND NOT device(st)`infusing? -> rmode,
                                           device(st)`infusing? -> infusemode
                                      ENDCOND,
                    	   middisp := LAMBDA(x: imid_type):
			   	       COND (x = dvtbi) OR (x = dtime) -> newvtbi(st) /= 0,
                                	    (x = drate) OR (x = dvol) -> TRUE,
                    			    ELSE -> FALSE ENDCOND,
                    	   fndisp1 := fvol,
			   fndisp2 := fvtbi,
			   fndisp3 := fnull,
			   device  := aug_vtbi(device(st), newvtbi(st)) ]

%%
  % @function key1_case_dispvtbi_bagmode
  % @description  when mode is bagmode and top line shows volume to be infused
  % @param {per_key1} st
  % @returns {state} goes to vtmode, adjusts displays, and sets temporary newvtbi to the appropriate bag volume, clears elapsed time
  % @memberof module: alaris_th
%% 

  key1_case_dispvtbi_bagmode(st: (per_key1)): state =
                  st WITH [ topline := dispvtbi,
	       	            middisp := LAMBDA(x: imid_type): x = dnewvtbi,
                            fndisp1 := fok,
			    fndisp2 := fbags,
			    fndisp3 := fquit,
			    entrymode  := vtmode,
			    newvtbi  := COND bagscursor(st) = 0 -> 0,
                                            bagscursor(st) = 1 -> 50,
                                            bagscursor(st) = 2 -> 100,
                                            bagscursor(st) = 3 -> 200,
                                            bagscursor(st) = 4 -> 250,
                                            bagscursor(st) = 5 -> 500,
                                            bagscursor(st) = 6 -> 1000,
                                            bagscursor(st) = 7 -> 1500,
                                            bagscursor(st) = 8 -> 2000,
                                            bagscursor(st) = mbags -> 3000 ENDCOND, 
                            device := resetElapsed(device(st))]

%%
  % @function key1_case_dispvtbi_tbagmode
  % @description  when top line shows vtbi and bag menu appears as part of setting vtbi over time (tbagmode)
  % @param {per_key1} st
  % @returns {state} sets newrate and newvtbi depending on bag choice and clears elapsed time, adjusting displays
  % @memberof module: alaris_th
%% 

  key1_case_dispvtbi_tbagmode(st: (per_key1)): state =
         LET nvtbi: nonneg_real = COND bagscursor(st) = 0 -> 0,
                                            bagscursor(st) = 1 -> 50,
                                            bagscursor(st) = 2 -> 100,
                                            bagscursor(st) = 3 -> 200,
                                            bagscursor(st) = 4 -> 250,
                                            bagscursor(st) = 5 -> 500,
                                            bagscursor(st) = 6 -> 1000,
                                            bagscursor(st) = 7 -> 1500,
                                            bagscursor(st) = 8 -> 2000,
                                            bagscursor(st) = mbags -> 3000 ENDCOND
          IN
                   st WITH [ topline := vtbitime,
		             middisp := LAMBDA(x: imid_type): (x = dnewvtbi) OR (x = dnewrate) OR (x = dnewtime),
                             fndisp1 := fok,
			     fndisp2 := fbags,
			     fndisp3 := fquit,
			     entrymode  := vttmode,
			     newvtbi  := nvtbi,
                             newrate := IF newtime(st) = 0 THEN 0
			     	     	ELSE nvtbi / newtime(st) ENDIF,
                             device := resetElapsed(device(st))
                           ]

%%
  % @function key1_case_options_dlock
  % @description  when infusion rate is locked and the unlock option is selected from the menu
  % @param {per_key1} st
  % @returns {state} goes to rmode or infusemode depending on whether the device is infusing or not and sets displays appropriately and clears elapsed time
  % @memberof module: alaris_th
%% 
 
  key1_case_options_dlock(st: (per_key1)): state =
     st WITH [ rlock := NOT rlock(st),
               topline := COND NOT device(st)`infusing? & 
                            device(st)`infusionrate /= 0 -> holding,
                               NOT device(st)`infusing? & 
                            device(st)`infusionrate = 0 -> holding,
                               device(st)`infusing? -> infusing
                          ENDCOND,
	       entrymode := COND NOT device(st)`infusing? -> rmode,
                               device(st)`infusing? -> infusemode
                          ENDCOND,
               middisp := LAMBDA(x: imid_type):
	       	            COND (x = drate) OR (x = dvol) -> TRUE,
			         (x = dvtbi) OR (x = dtime) -> device(st)`vtbi /= 0,
				 ELSE -> FALSE ENDCOND,
               fndisp1 := fvol,
	       fndisp2 := fvtbi,
	       fndisp3 := fnull,
	       device  := resetElapsed(device(st)) ]

%%
  % @function key1_case_options_dsetvtbi
  % @description  when set vtbi over time is chosen from the options menu
  % @param {per_key1} st
  % @returns {state} top line shows vtbi over time, mode vttmode, temporary newvtbi and newtime initialised as defined by actual device, appropriate displays and clears elapsed time
  % @memberof module: alaris_th
%% 

  key1_case_options_dsetvtbi(st: (per_key1)): state = 
     st WITH [ topline := vtbitime,
               newvtbi := 0,
               newtime := 1,
               device  := resetElapsed(device(st)),
               middisp := LAMBDA(x: imid_type): (x = dnewrate) OR (x = dnewvtbi) OR (x = dnewtime),
	       fndisp1 := fok,
	       fndisp2 := fbags,
               fndisp3 := fquit,
	       entrymode  := vttmode ]

%%
  % @function key1_case_options_dsetvtbilocked
  % @description  when trying to set vtbi over time when the infusion rate is locked
  % @param {per_key1} st
  % @returns {state} shows top line of locked, and stays in options menu mode
  % @memberof module: alaris_th
%% 

key1_case_options_dsetvtbilocked(st: (per_key1)): state = 
     st WITH [ topline := locked,
               middisp := LAMBDA(x: imid_type): FALSE,
               fndisp1 := fnull,
	       fndisp2 := fnull,
               fndisp3 := fnull,
	       entrymode  := qmode ]

%%
  % @function key1_case_options_ddosing_dsetup_dadjustav_dpdtls
  % @description  when selecting other information entries from the options menu
  % @param {per_key1} st
  % @returns {state} shows top line of information - this element is not populated in the model
  % @memberof module: alaris_th
%% 

  key1_case_options_ddosing_dsetup_dadjustav_dpdtls(st: (per_key1)): state =
     st WITH [ topline := dispinfo,
               middisp := LAMBDA(x: imid_type): FALSE,
               fndisp1 := fnull,
	       fndisp2 := fnull,
               fndisp3 := fquit,
	       entrymode  := nullmode,
               device  := resetElapsed(device(st)) ]

%%
  % @function key1_case_options_ddisablerate
  % @description  disabling infusion rate lock / unlock in the options menu
  % @param {per_key1} st
  % @returns {state} returns to rmode or infusemode, depending whether paused or infusing
  % @memberof module: alaris_th
%% 

  key1_case_options_ddisablerate(st: (per_key1)): state =
      st WITH [ rdisabled := NOT rdisabled(st),
                topline := COND NOT device(st)`infusing? & 
                               device(st)`infusionrate /= 0 -> holding,
                               NOT device(st)`infusing? & 
                               device(st)`infusionrate = 0 -> setrate,
                               device(st)`infusing? -> infusing
                          ENDCOND,
	        entrymode := COND NOT device(st)`infusing? -> rmode,
                               device(st)`infusing? -> infusemode
                          ENDCOND,
                middisp := LAMBDA(x: imid_type):
	       	            COND (x = drate) OR (x = dvol) -> TRUE,
			         (x = dvtbi) OR (x = dtime) -> device(st)`vtbi /= 0,
                                  ELSE -> FALSE ENDCOND,
                fndisp1 := fvol,
	        fndisp2 := fvtbi,
	        fndisp3 := fnull,
	        device  := resetElapsed(device(st)) ]

%%
  % @function key1_case_vtbitime_vttmode
  % @description  continues the sequence for setting vtbi over time when vtbi non zero, shows top line vtbi over time, 
  % @param {per_key1} st
  % @returns {state} sets mode to ttmode and clears elapsed time, back will take to vttmode
  % @memberof module: alaris_th
%% 

  key1_case_vtbitime_vttmode(st: (per_key1)): state =
      st WITH [ topline := vtbitime,
                middisp := LAMBDA(x: imid_type): (x = dnewrate) OR (x = dnewvtbi) OR (x = dnewtime),
                device  := resetElapsed(device(st)),
                fndisp1 := fok,
		fndisp2 := fnull,
                fndisp3 := fback,
		entrymode  := ttmode ]

%%
  % @function key1_case_vtbitime_vtbiZ
  % @description  continues the sequence for setting vtbi over time when vtbi zero 
  % @param {per_key1} st
  % @returns {state} in this case escapes the sequence and returns to holding (rmode) only available when device paused
  % @memberof module: alaris_th
%% 

  key1_case_vtbitime_vttmode_vtbiZ(st: (per_key1)): state =
      st WITH [ topline :=
                    COND
                      device(st)`infusionrate = 0 -> setrate,
                      ELSE -> holding
                    ENDCOND,
      	        middisp := LAMBDA(x: imid_type): (x = drate) OR (x = dvol),
                device := aug_vtbi(device(st), 0),
                fndisp1 := fvol,
		fndisp2 := fvtbi,
		fndisp3 := fnull,
                entrymode  := rmode ]

%%
  % @function key1_case_vtbitime_ttmode
  % @description  completes the sequence for setting vtbi over time
  % @param {per_key1} st
  % @returns {state} in this case escapes the sequence and returns to holding (rmode) only available when device paused and updates vtbi and time with the temporary values newvtbi and newtime
  % @memberof module: alaris_th
%% 

   key1_case_vtbitime_ttmode(st: (per_key1)): state =
     LET newdevice = modvtbitime(newvtbi(st), newtime(st))(device(st))
      IN st WITH [ 
               topline :=  
                     COND newdevice`infusionrate = 0 -> setrate,
                          ELSE -> holding ENDCOND,
               middisp := LAMBDA(x: imid_type): (x = drate) OR (x = dvtbi) OR (x = dtime) OR (x = dvol),
	       fndisp1 := fvol,
	       fndisp2 := fvtbi,
               fndisp3 := fnull,
	       entrymode  := rmode,
	       device  := newdevice ]

 %%
  % @function key1
  % @description  deals with fifteen cases depending on conditions
  % @param {per_key1} st
  % @returns {state}
  % @memberof module: alaris_th
%% 

  key1(st:  (per_key1)): state =
        COND
         (topline(st) = holding OR topline(st) = setrate) OR (topline(st) = infusing) OR
         (topline(st) = dispkvo)  
               -> key1_case_holdinginfusingdispkvo(st),
         topline(st) = clearsetup ->
                  key1_case_clearsetup(st),
         topline(st) = lockrate ->
                   key1_case_infuselocked(st),
	 topline(st) = dispvtbi ->  
               COND entrymode(st) = vtmode    -> key1_case_dispvtbi_vtmode(st),
		    entrymode(st) = bagmode   -> key1_case_dispvtbi_bagmode(st),
                    entrymode(st) = tbagmode  -> key1_case_dispvtbi_tbagmode(st)
        	   ENDCOND,
         topline(st) = options  -> 
             COND (optionsmenu(st)(qcursor(st)) = ratelock) OR 
                   (optionsmenu(st)(qcursor(st)) = rateunlock)            
                        -> key1_case_options_dlock(st),
	 	 (optionsmenu(st)(qcursor(st)) = setvtbiovertime) & 
                 NOT rlock(st)          
                        -> key1_case_options_dsetvtbi(st),
                  (optionsmenu(st)(qcursor(st)) = setvtbiovertime) & rlock(st)          
                        -> key1_case_options_dsetvtbilocked(st),
                   (optionsmenu(st)(qcursor(st)) = disableratelock) OR
                      (optionsmenu(st)(qcursor(st)) = enableratelock)      
                        -> key1_case_options_ddisablerate(st),
                    ELSE -> 
                     key1_case_options_ddosing_dsetup_dadjustav_dpdtls(st)
         ENDCOND,
         topline(st) = vtbitime & entrymode(st)=vttmode & newvtbi(st) /= 0      
                        -> key1_case_vtbitime_vttmode(st),
         topline(st) = vtbitime & entrymode(st)=vttmode & newvtbi(st) = 0      
                        -> key1_case_vtbitime_vttmode_vtbiZ(st),
         topline(st) = vtbitime & entrymode(st)=ttmode
                        ->  key1_case_vtbitime_ttmode(st)
        ENDCOND

%%
  % @function per_key2
  % @description key2 is permitted in a range of conditions - these are all described and correspond to cases to follow
  % @param {state} st
  % @returns {bool} 
  % @memberof module: alaris_th
%%

   per_key2(st: state): bool =
   	no_button_down(st) &
               (((topline(st) = holding OR topline(st) = setrate) & 
                     entrymode(st) = rmode & fndisp2(st) = fvtbi) OR 
                (topline(st) = infusing & fndisp2(st) = fvtbi &
                 entrymode(st) = infusemode & NOT device(st)`kvoflag) OR 
                (topline(st) = volume & entrymode(st) = nullmode & 
                 fndisp2(st) = fclear & middisp(st)(dvol)) OR 
                 ((((topline(st) = dispvtbi) AND (entrymode(st) = vtmode)) OR
                  ((topline(st) = vtbitime) AND (entrymode(st) = vttmode))) AND
                   (fndisp2(st) = fbags)) OR
                 ((topline(st) = setvtbi) AND (entrymode(st) = nullmode) AND (fndisp2(st) = fvtbi)))
               & (device(st)`powered_on?)


 %%
  % @function key2
  % @description  deals with three cases depending on conditions
  % @param {per_key2} st
  % @returns {state}
  % @memberof module: alaris_th
%% 

%%
  % @function key2_case_holding_infusing
  % @description moves from rmode to vtmode
  % @param {per_key2} st
  % @returns {state} sets up the display appropriately, and clears elapsed time
  % @memberof module: alaris_th
%% 

  key2_case_holding_infusing(st: (per_key2)): state =
      st WITH [ topline := dispvtbi,
                newvtbi := device(st)`vtbi,
                middisp := LAMBDA(x: imid_type): (x = dnewvtbi),
                fndisp1 := fok,
		fndisp2 := fbags,
		fndisp3 := fquit,
		entrymode := vtmode,
                device  := resetElapsed(device(st)) ]

%%
  % @function key2_case_volume
  % @description returns from topline of volume (clears volume infused) to rmode or infusemode
  % @param {per_key2} st
  % @returns {state} returns to rmode or infusemode with appropriate displays and clears the volume infused, sets function key2 to fvtbi unless infusing and in KVO mode
  % @memberof module: alaris_th
%% 
 
  key2_case_volume(st: (per_key2)): state = 
   st WITH [ topline := COND device(st)`infusing? AND device(st)`powered_on? AND
                                     NOT device(st)`kvoflag -> infusing,
                             device(st)`infusing? AND device(st)`powered_on? AND
                                     device(st)`kvoflag -> dispkvo,
      	     	     	     NOT device(st)`infusing? AND 
                                 device(st)`powered_on? AND 
                                 device(st)`infusionrate /= 0 -> holding,
                             NOT device(st)`infusing? AND 
                                 device(st)`powered_on? AND 
                                 device(st)`infusionrate = 0 -> setrate,
                             NOT device(st)`powered_on? -> dispblank ENDCOND,
             entrymode   := COND device(st)`infusing? AND device(st)`powered_on? -> infusemode,
	     	                 NOT device(st)`infusing? AND device(st)`powered_on? -> rmode,
                                 NOT device(st)`powered_on? -> nullmode ENDCOND,

             middisp := LAMBDA(x: imid_type):
	                  COND (x = dvtbi) OR (x = dtime) -> device(st)`vtbi /= 0,
                               (x = dvol) OR (x = drate) -> TRUE,
			       ELSE -> FALSE ENDCOND,

             device  := clearVolumeinfused(device(st)),
             
             fndisp1 := fvol,
             fndisp2 := COND device(st)`infusing? AND device(st)`powered_on? AND
                                     device(st)`kvoflag -> fnull, 
                             ELSE -> fvtbi ENDCOND,
	     fndisp3 := fnull ]

%%
  % @function key2_case_dispvtbiORvtbitime
  % @description takes from vtmode or vttmode to appropriate bagmode
  % @param {per_key2} st
  % @returns {state} clears elapsed time and sets displays appropriately
  % @memberof module: alaris_th
%% 

  key2_case_dispvtbiORvtbitime(st: (per_key2)): state =
      st WITH [ topline := dispvtbi,
                middisp := LAMBDA(x: imid_type): x = dbags,
                bagscursor := midbag,
                fndisp1 := fok,
                fndisp2 := fnull,
		fndisp3 := fback,
		device  := resetElapsed(device(st)),
                entrymode := IF (topline(st) = dispvtbi) THEN bagmode
                             ELSIF topline(st) = vtbitime THEN tbagmode
                             ELSE nullmode ENDIF ]

%%
  % @function key2
  % @description  deals with three cases depending on conditions
  % @param {per_key2} st
  % @returns {state}
  % @memberof module: alaris_th
%% 

  key2(st: (per_key2)): state =
        COND
          (topline(st) = holding OR topline(st) = setrate OR topline(st) = infusing OR topline(st) = setvtbi)   
                 -> key2_case_holding_infusing(st),
          (topline(st) = volume)                             
                 -> key2_case_volume(st),
          (topline(st) = dispvtbi OR topline(st) = vtbitime) 
                 -> key2_case_dispvtbiORvtbitime(st)
        ENDCOND

%%
  % @function per_key3
  % @description key3 is permitted in a range of conditions - these are all described and correspond to cases to follow
  % @param {state} st
  % @returns {bool} 
  % @memberof module: alaris_th
%%

  per_key3(st: state): bool =
     device(st)`powered_on? & no_button_down(st) &
     (((((topline(st) = vtbidone) AND (fndisp3(st) = fcancel) AND (entrymode(st) = nullmode) AND 
           device(st)`kvoflag) OR
        ((topline(st) = dispvtbi) AND 
          (((entrymode(st) = vtmode AND fndisp3(st) = fquit) OR 
            (entrymode(st) = bagmode AND fndisp3(st) = fback)) AND NOT device(st)`kvoflag)) OR
          ((topline(st) = dispinfo) & (fndisp3(st) = fquit) & (NOT device(st)`kvoflag) & 
               (entrymode(st) = nullmode)) OR
           ((topline(st) = options) & (entrymode(st) = qmode) & (fndisp3(st) = fquit) & 
                NOT device(st)`kvoflag)) & device(st)`infusing?) OR
       ((((topline(st) = attention) & (fndisp3(st) = fcancel) & 
              (entrymode(st) = nullmode)) OR 
          (topline(st) = clearsetup & fndisp3(st) = fkeep & 
                entrymode(st) = nullmode & middisp(st)(drate)) OR
        (((topline(st) = setvtbi & fndisp3(st) = fcancel & entrymode(st) = nullmode) OR 
           (topline(st) = lockrate & fndisp3(st) = fno & NOT device(st)`infusing? & 
             device(st)`vtbi /= 0 & device(st)`infusionrate /= 0) OR
          (topline(st) = setnotfitted & fndisp3(st) = fcancel))  
            & entrymode(st) = nullmode) OR 
        (topline(st) = vtbitime & ((entrymode(st) = vttmode & fndisp3(st) = fquit) 
                                  OR (entrymode(st) = ttmode & fndisp3(st) = fback) )) OR
       ((topline(st) = dispvtbi) & ((entrymode(st) = tbagmode & fndisp3(st) = fback) OR 
                                     (entrymode(st) = vtmode & fndisp3(st) = fquit) OR
                                    (entrymode(st) = bagmode & fndisp3(st) = fback)) ) OR
        (topline(st) = dispinfo & entrymode(st) = nullmode & fndisp3(st) = fquit) OR 
        ((topline(st) = options) & (entrymode(st) = qmode) & 
                   (fndisp3(st) = fquit))) & NOT device(st)`infusing?) OR
       (topline(st) = volume & entrymode(st) = nullmode & fndisp3(st) = fquit) OR 
       (topline(st) = batterylow & entrymode(st) = nullmode & fndisp3(st) = fcancel))

%%
  % @function key3
  % @description  deals with ten cases depending on conditions
  % @param {per_key3} st
  % @returns {state}
  % @memberof module: alaris_th
%% 

%%
  % @function key3_case_attention_clearsetup
  % @description when starting the device and top line shows clear set up, and old pump parameters kept
  % @param {per_key3} st
  % @returns {state} goes to rmode, with appropriate top line if rate zero, resets elapsed time
  % @memberof module: alaris_th
%% 
   
  key3_case_attention_clearsetup(st: (per_key3)): state = 
      st WITH [ topline := 
                 COND device(st)`infusionrate = 0 -> setrate,
                      ELSE -> holding ENDCOND,
                middisp := LAMBDA(x: imid_type):
		            COND (x = drate) OR (x = dvol) -> TRUE,
			         (x = dvtbi) OR (x = dtime) -> device(st)`vtbi /= 0,
			         ELSE -> FALSE ENDCOND,
                fndisp1 := fvol,
		fndisp2 := fvtbi,
                fndisp3 := fnull,
		entrymode  := rmode,
		device  := resetElapsed(device(st)) ]

%%
  % @function key3_case_battery_low
  % @description key3 pressed when topline battery low, returns to top line infusing, KVO, setrate, holding
  % @param {per_key3} st
  % @returns {state} sets displays and clears elapsed time
  % @memberof module: alaris_th
%% 

   key3_case_battery_low(st: (per_key3)): state = 
      st WITH [ topline := COND device(st)`infusing? AND NOT device(st)`kvoflag -> infusing,
                                device(st)`infusing? AND device(st)`kvoflag -> dispkvo,
                                NOT device(st)`infusing? & device(st)`infusionrate = 0
                                        -> setrate,
                                ELSE -> holding
                           ENDCOND,
                middisp := 
                  COND NOT device(st)`infusing? -> 
                           LAMBDA(x: imid_type):
		            COND (x = drate) OR (x = dvol) -> TRUE,
			         (x = dvtbi) OR (x = dtime) -> device(st)`vtbi /= 0,
			          ELSE -> FALSE ENDCOND,
                        ELSE ->
                          LAMBDA(x: imid_type):
                           COND x = drate -> NOT device(st)`kvoflag,
                                x = dkvorate -> device(st)`kvoflag,
                                (x = dvtbi) OR (x = dvol) OR (x = dtime) -> TRUE,
				ELSE -> FALSE ENDCOND
                        ENDCOND,
                fndisp1 := fvol,
		fndisp2 := COND NOT (device(st)`infusing? AND device(st)`kvoflag) -> fvtbi,
                           ELSE -> fnull ENDCOND,
                fndisp3 := fnull,
		entrymode  := COND NOT device(st)`infusing? -> rmode,
                                   ELSE -> infusemode
                              ENDCOND,
		device  := resetElapsed(device(st)) ]

%%
  % @function key3_case_infuse
  % @description key3 pressed when lock rate displayed - starts the infusion if permitted
  % @param {per_key3} st
  % @returns {state} sets display for infusing without locking the rate
  % @memberof module: alaris_th
%% 


  key3_case_infuse(st: (per_key3)): state =
         st WITH [ device := 
                  IF per_start(st`device) THEN start(st`device)
                  ELSE st`device
                  ENDIF,
              topline := infusing,
              middisp := LAMBDA(x: imid_type): (x = drate) OR (x = dvtbi) OR (x = dvol) OR (x = dtime),
              fndisp1 := fvol,
              fndisp2 := fvtbi,
              fndisp3 := fnull,
              entrymode  := infusemode,
              runlight := TRUE,
              pauselight := FALSE ]

%%
  % @function key3_case_volume
  % @description key3 pressed when topline shows volume
  % @param {per_key3} st
  % @returns {state} sets displys depending on whether the device is infusing or paused, or in KVO mode
  % @memberof module: alaris_th
%% 


  key3_case_volume(st: (per_key3)): state =
       st WITH [ topline := COND
                              device(st)`infusing? AND device(st)`powered_on? ->
                                        COND NOT device(st)`kvoflag  -> infusing,
       	                                          device(st)`kvoflag -> dispkvo ENDCOND,
                              NOT device(st)`infusing? AND 
                                  device(st)`powered_on? & device(st)`infusionrate = 0 -> 
                                         setrate,
                              NOT device(st)`infusing? AND device(st)`powered_on? 
                                 & device(st)`infusionrate /= 0 -> holding,
                              NOT device(st)`powered_on? -> dispblank
                            ENDCOND,
       	         middisp := LAMBDA(x: imid_type):
		 	      COND (x = dvtbi) OR (x = dtime) -> device(st)`vtbi /= 0,
                                   x = drate -> NOT(device(st)`infusing? AND device(st)`kvoflag),
				   x = dvol  -> TRUE,
				   x = dkvorate -> device(st)`infusing? AND device(st)`kvoflag,
                                   ELSE -> FALSE
                              ENDCOND,
                 entrymode := COND
                                device(st)`infusing? AND device(st)`powered_on? -> infusemode,
                                NOT device(st)`infusing?  AND device(st)`powered_on? -> rmode,
                                NOT device(st)`powered_on?  -> nullmode
                            ENDCOND,

                 fndisp1 :=  fvol,
                            
                 fndisp2 := COND 
                             device(st)`infusing? AND device(st)`powered_on? AND
                                   NOT device(st)`kvoflag -> fvtbi, 
                             NOT device(st)`infusing? AND device(st)`powered_on?  
                                         -> fvtbi,
                             ELSE -> fnull   
                            ENDCOND,    
		 fndisp3 := fnull,
              	 device  := resetElapsed(device(st)) ]

%%
  % @function key3_case_vtbidone
  % @description key3 pressed when vtbi done 
  % @param {per_key3} st
  % @returns {state} continues infusing in KVO mode, only available key enables check of volume
  % @memberof module: alaris_th
%% 


  key3_case_vtbidone(st: (per_key3)): state =
   st WITH [ topline := dispkvo,
             middisp := LAMBDA(x: imid_type): (x = dkvorate) OR (x = dvtbi) OR (x = dvol) OR (x = dtime),
	     fndisp1 := fvol,
	     fndisp2 := fnull,
	     fndisp3 := fnull,
             entrymode := infusemode,
             device  := resetElapsed(device(st)) ]

%%
  % @function key3_dispvtbi_vtmode
  % @description key3 pressed when in vtmode
  % @param {per_key3} st
  % @returns {state} returns to holding or infusing, depending on mode of device. When holding and infusion rate is zero then shows set rate, clears elapsed time, shows KVO if infusing when vtbi zero 
%% 


  key3_case_dispvtbi_vtmode(st: (per_key3)): state =    
        st WITH [ topline := COND
                              NOT device(st)`infusing? AND 
                                  device(st)`powered_on? & 
                                     device(st)`infusionrate = 0 -> setrate,
                              NOT device(st)`infusing? AND 
                                  device(st)`powered_on? & 
                                     device(st)`infusionrate /= 0 -> holding,
                              NOT device(st)`kvoflag AND device(st)`infusing? AND 
                                  device(st)`powered_on? -> infusing,
                              device(st)`kvoflag AND device(st)`infusing? AND 
                                  device(st)`powered_on? -> dispkvo,
                              NOT device(st)`powered_on? -> dispblank
                             ENDCOND,
                  device  := resetElapsed(device(st)),
                  middisp := LAMBDA(x: imid_type):
		               COND (x = dvtbi AND (NOT device(st)`kvoflag)) -> 
                                         (device(st)`vtbi /= 0),
                                    (x = dvtbi AND device(st)`kvoflag) -> FALSE,
			            x = dtime -> device(st)`vtbi /= 0,
				    (x = drate) OR (x = dvol) -> TRUE,
				    x = dkvorate -> device(st)`kvoflag,
       				    ELSE -> FALSE ENDCOND,
                  fndisp1 := fvol,
		  fndisp2 := COND device(st)`infusing? AND device(st)`kvoflag -> fnull,
                              ELSE -> fvtbi ENDCOND,
		  fndisp3 := fnull,
		  entrymode := COND
                                NOT device(st)`infusing? AND device(st)`powered_on? -> rmode,
                                device(st)`infusing? AND device(st)`powered_on? -> infusemode,
                                NOT device(st)`powered_on? -> nullmode
                               ENDCOND ]

%%
  % @function key3_case_dispvtbi_bagmode
  % @description key3 pressed when in bag mode 
  % @param {per_key3} st
  % @returns {state} returns to vtmode, resets elapsed
%% 


  key3_case_dispvtbi_bagmode(st: (per_key3)): state =
   st WITH [ topline := dispvtbi,
             middisp := LAMBDA(x: imid_type): x = dnewvtbi,
             fndisp1 := fok,
	     fndisp2 := fbags,
	     fndisp3 := fquit,
	     entrymode := vtmode,
	     device  := resetElapsed(device(st)) ]

%%
  % @function key3_case_dispvtbi_tbagmode
  % @description key3 pressed when in tbagmode (ie bag mode when entering vtbi over time 
  % @param {per_key3} st
  % @returns {state} returns to vttmode, vtbi over time resets elapsed
%% 


 key3_case_dispvtbi_tbagmode(st: (per_key3)): state =
   st WITH [ topline := vtbitime,
             middisp := LAMBDA(x: imid_type): (x = dnewtime) OR (x = dnewrate) OR (x = dnewvtbi),
             fndisp1 := fok,
	     fndisp2 := fbags,
	     fndisp3 := fquit,
	     entrymode := vttmode,
	     device  := resetElapsed(device(st)) ]

%%
  % @function key3_case_setvtbi_rate_notfitted
  % @description key3 pressed when warning that giving set not fitted 
  % @param {per_key3} st
  % @returns {state} returns to holding or set rate depending on whether infusion rate is zero
%% 


  key3_case_setvtbi_rate_notfitted(st: (per_key3)): state =
   st WITH [ topline := COND device(st)`infusionrate /= 0 -> holding,
                             ELSE -> setrate ENDCOND,
              middisp := LAMBDA(x: imid_type):
		            COND (x = drate) OR (x = dvol) -> TRUE,
			         (x = dvtbi) OR (x = dtime) -> device(st)`vtbi /= 0,
			         ELSE -> FALSE ENDCOND,
             fndisp1 := fvol,
	     fndisp2 := fvtbi,
             fndisp3 := fnull,
	     entrymode  := rmode,
	     device  := resetElapsed(device(st))]

%%
  % @function key3_case_optionsORdispinfo
  % @description key3 pressed when showing options menu or information display within options menu
  % @param {per_key3} st
  % @returns {state} returns to holding or infusing depending on the mode of the device, resets elapsed
%% 


  key3_case_optionsORdispinfo(st: (per_key3)): state = 
   st WITH [ topline := COND NOT device(st)`infusing? & 
                              device(st)`infusionrate /= 0-> holding,
                             NOT device(st)`infusing? & 
                              device(st)`infusionrate = 0-> setrate,
                             device(st)`infusing? -> infusing
                        ENDCOND,
             middisp := LAMBDA(x: imid_type):
	                 COND (x = drate) OR (x = dvol) -> TRUE,
			      (x = dvtbi) OR (x = dtime) -> device(st)`vtbi /= 0,
			     ELSE -> FALSE ENDCOND,
              fndisp1 := fvol,
	      fndisp2 := fvtbi,
	      fndisp3 := fnull,
	      entrymode :=  COND NOT device(st)`infusing? AND device(st)`powered_on? -> rmode,
                             device(st)`infusing? AND device(st)`powered_on? -> infusemode,
                             NOT device(st)`powered_on? -> nullmode
                            ENDCOND,
	      device  := resetElapsed(device(st)) ]

%%
  % @function key3_case_vtbitime_vttmode
  % @description key3 pressed when entering vtbi within vtbi over time
  % @param {per_key3} st
  % @returns {state} returns to holding or set rate depending on value of infusion rate, resets elapsed time
%% 



  key3_case_vtbitime_vttmode(st: (per_key3)): state =
    st WITH [ topline := COND device(st)`infusionrate /= 0 -> holding,
                              ELSE -> setrate ENDCOND,
              middisp := LAMBDA(x: imid_type):
	                  COND (x = drate) OR (x = dvol) -> TRUE,
                  	       (x = dvtbi) OR (x = dtime) -> device(st)`vtbi /= 0,
                  	       ELSE -> FALSE ENDCOND,
               fndisp1 := fvol,
	       fndisp2 := fvtbi,
               fndisp3 := fnull,
	       entrymode  := rmode,
	       device  := resetElapsed(device(st)) ]

%%
  % @function key3_case_vtbitime_ttmode
  % @description key3 pressed when entering time in vtbi over time
  % @param {per_key3} st
  % @returns {state} returns to the state when entering vtbi in vtbi over time
%% 



  key3_case_vtbitime_ttmode(st: (per_key3)): state =
    st WITH [ topline := vtbitime,
              middisp := LAMBDA(x: imid_type): x = dnewrate OR x = dnewvtbi OR x = dnewtime,
              fndisp1 := fok,
	      fndisp2 := fbags,
	      fndisp3 := fquit,
	      entrymode := vttmode,
              device  := resetElapsed(device(st)) ]

%%
  % @function key3
  % @description  deals with ten cases depending on conditions
  % @param {per_key3} st
  % @returns {state}
  % @memberof module: alaris_th
%% 


  key3(st: (per_key3)): state =
         COND
            (topline(st) = attention OR topline(st) = clearsetup)               
                  ->  key3_case_attention_clearsetup(st),
            (topline(st) = batterylow) -> key3_case_battery_low(st),
            (topline(st) = lockrate) ->
                    key3_case_infuse(st),
	    topline(st) = volume                     
                  ->  key3_case_volume(st),
            topline(st) = vtbidone
                  ->  key3_case_vtbidone(st),
            topline(st) = dispvtbi                  
                  ->  COND entrymode(st) = vtmode  
                             ->  key3_case_dispvtbi_vtmode(st),
	    		   entrymode(st) = bagmode 
                             ->  key3_case_dispvtbi_bagmode(st),
                           entrymode(st) = tbagmode 
                             -> key3_case_dispvtbi_tbagmode(st) ENDCOND,
            ((topline(st) = setvtbi AND entrymode(st) = nullmode) OR
                (topline(st) = setnotfitted))                    
                  ->  key3_case_setvtbi_rate_notfitted(st),
	    topline(st) = options OR topline(st) = dispinfo              
                  ->  key3_case_optionsORdispinfo(st),
	    topline(st) = vtbitime & entrymode(st) = vttmode     
                  ->  key3_case_vtbitime_vttmode(st),
	    topline(st) = vtbitime & entrymode(st) = ttmode      
                  ->  key3_case_vtbitime_ttmode(st)
        ENDCOND
   
% General permission associated with chevron keys
%%
  % @function per_chevron
  % @description chevron (general for of sup, fup, sdown, fdown) is permitted in a range of conditions - these are all described and correspond to cases to follow
  % @param {state} st
  % @returns {bool} 
  % @memberof module: alaris_th
%%

  per_chevron(st: state): bool =
             device(st)`powered_on? & 
      (NOT device(st)`infusing? &
         (topline(st) = holding OR topline(st) = setrate) & (entrymode(st) = rmode) & 
            middisp(st)(drate) &
            (middisp(st)(dvtbi) = (device(st)`vtbi /= 0)) &
            (middisp(st)(dtime) = (device(st)`vtbi /= 0)) &
           (fndisp1(st) = fvol & fndisp2(st) = fvtbi & 
            fndisp3(st) = fnull)) OR
       (device(st)`infusing? &
           (topline(st) = infusing & entrymode(st) = infusemode & 
            middisp(st)(drate) & middisp(st)(dtime) & middisp(st)(dvtbi) &
            fndisp1(st) = fvol & fndisp2(st) = fvtbi & fndisp3(st) = fnull)) OR
       ((topline(st) = dispvtbi) & 
           (((entrymode(st) = vtmode) & middisp(st)(dnewvtbi) AND 
            (fndisp1(st) = fok) & (fndisp2(st) = fbags) & 
            (fndisp3(st) = fquit)) OR 
           ((entrymode(st) = bagmode) & 
           (fndisp1(st) = fok) & (fndisp2(st) = fnull) & 
           (fndisp3(st) = fback)))) OR
        (NOT device(st)`infusing? &
           (((topline(st) = dispvtbi) & (entrymode(st) = tbagmode) &
            (fndisp1(st) = fok) & (fndisp2(st) = fnull) & 
            (fndisp3(st) = fback)) OR
            ((topline(st) = vtbitime) & 
               (((entrymode(st) = vttmode) & 
                (fndisp1(st) = fok) & (fndisp2(st) = fbags) & 
                (fndisp3(st) = fquit)) OR 
               ((entrymode(st) = ttmode) & (fndisp1(st) = fok) & 
                (fndisp2(st) = fnull) &  (fndisp3(st) = fback))) & 
               (middisp(st)(dnewvtbi) & middisp(st)(dnewtime) & 
               middisp(st)(dnewrate))))) OR 
            ((topline(st) = options) & (entrymode(st) = qmode) & 
               (fndisp1(st) = fok) & (fndisp2(st) = fnull) & 
               (fndisp3(st) = fquit)) 

% specific permissions associated with the chevron keys that use the general permission above
 
%%
  % @function per_fup
  % @description uses general chevron permission, specific to fup
  % @param {state} st
  % @returns {bool} 
  % @memberof module: alaris_th
%%              
  per_fup(st:state): bool = (no_button_down(st) OR 
                                       (which_press(st) = fupb AND pressed(st) < maxpress)) &
                              per_chevron(st)

%%
  % @function per_sup
  % @description uses general chevron permission, specific to sup
  % @param {state} st
  % @returns {bool} 
  % @memberof module: alaris_th
%% 
  per_sup(st: state): bool = (no_button_down(st) OR 
                              (which_press(st) = supb AND pressed(st) < maxpress)) & 
                              per_chevron(st)

%%
  % @function per_fdown
  % @description uses general chevron permission, specific to fdown
  % @param {state} st
  % @returns {bool} 
  % @memberof module: alaris_th
%% 
  per_fdown(st: state): bool = (no_button_down(st) OR 
                                       (which_press(st) = fdownb AND pressed(st) < maxpress)) &
                              per_chevron(st)

%%
  % @function per_sdown
  % @description uses general chevron permission, specific to sdown
  % @param {state} st
  % @returns {bool} 
  % @memberof module: alaris_th
%% 
  per_sdown(st: state): bool = (no_button_down(st) OR 
                                       (which_press(st) = sdownb AND pressed(st) < maxpress)) &
                              per_chevron(st)

% Fast up chevron key associated with infusion rate

%%
  % @function state_UP_rate
  % @description used by fup to increment rate by step defined by the value of the rate
  % @param {steprate} d
  % @param {irates} v
  % @returns {irates} returns new value of infusion rate
%% 

  state_UP_rate(d: steprate, v: irates): irates =
    IF v<100 THEN trim_rate(floor(v) + d)
    ELSIF v>=100 AND v<1000 THEN trim_rate((floor(v/10) + d)*10)
    ELSE trim_rate((floor(v/100) + d) * 100) ENDIF

%%
  % @function fup
  % @description  deals with three cases relating to fup and infusion rate depending on conditions
  % @description deals with two cases relating to fup and vtbi depending on conditions
  % @description one case associated with time
  % @description two cases associated with bags (when updating vtbi and when updating vtbi over time
  % @description one option associated with the options menu
  % @param {per_fup} st
  % @returns {state}
  % @memberof module: alaris_th
%% 

%%
  % @function fup_case_holding_NOTrlock
  % @description  when pump holding and infusion rate not locked
  % @param {presstime} d pressing of key which accelerates the step, augments infusion rate
  % @param {per_fup} st
  % @returns {state}
  % @memberof module: alaris_th
%% 

  fup_case_holding_NOTrlock(d: presstime, st: (per_fup)): state =
    LET v: irates = device(st)`infusionrate,
        s: steprate = 
            IF d=0 AND current_sr(st) = small_step AND
               ((v<100 AND fractional(v/10)=0) OR
                (v>100 AND fractional(v/100)=0)) THEN big_step ELSE
                current_sr(st) ENDIF,
        r: irates = state_UP_rate(s, v)
        IN
          st WITH [device := aug_rate(device(st), r),
                   topline := COND r = 0 -> setrate,
                                   ELSE -> holding ENDCOND,
                   current_sr := s]

%%
  % @function fup_case_infusing_NOTrlock
  % @description  when pump infusing and infusion rate not locked
  % @param {presstime} d pressing of key which accelerates the step augments the infusion rate
  % @param {per_fup} st
  % @returns {state}
  % @memberof module: alaris_th
%% 

   fup_case_infusing_NOTrlock(d: presstime, st: (per_fup)): state =
    LET v: irates = device(st)`infusionrate,
        s: steprate = 
            IF d=0 AND current_sr(st) = small_step AND
               ((v<100 AND fractional(v/10)=0) OR
                (v>100 AND fractional(v/100)=0)) THEN big_step ELSE
                current_sr(st) ENDIF,
        r: irates = state_UP_rate(s, v)
        IN
          st WITH [device := aug_rate(device(st), r),
                   current_sr := s]

  %%
  % @function fup_case_infusingORholding_NOTrlock
  % @description  when pump infusing or holding and infusion rate locked
  % @param {per_fup} st
  % @returns {state} shows locked and amends the display
  % @memberof module: alaris_th
%%   

  fup_case_infusingORholding_rlock(st: (per_fup)): state =
    st WITH [ topline := locked,
              middisp := LAMBDA(x: imid_type): FALSE,
             fndisp1 := fnull,
	     fndisp2 := fnull,
             fndisp3 := fnull,
             device  := resetElapsed(device(st)) ]

% Fast up chevron key associated with volume to be infused

%%
  % @function state_UP_vtbi
  % @description used by fup to increment vtbi by step defined by the value of the vtbi
  % @param {stepvol} d
  % @param {ivols} v
  % @returns {ivols} returns new value of vtbi
%% 

  state_UP_vtbi(d: stepvol, v: ivols): ivols =
    IF v<100 THEN trim_vtbi(floor(v) + d)
    ELSIF v>=100 AND v<1000 THEN trim_vtbi((floor(v/10) + d)*10)
    ELSE trim_vtbi((floor(v/100) + d) * 100) ENDIF

 %%
  % @function fup_case_dispvtbi_vtmode
  % @description  when display vtbi in top line and in vtmode
  % @param {presstime} d pressing of key which accelerates the step augments the vtbi
  % @param {per_fup} st
  % @returns {state} updates vtbi
  % @memberof module: alaris_th
%%  

  fup_case_dispvtbi_vtmode(d: presstime, st: (per_fup)): state =
    LET s: stepvol = 
            IF d=0 AND current_sv(st) = small_step AND
               ((newvtbi(st) < 100 AND fractional(newvtbi(st)/10)=0) OR
                (newvtbi(st)>100 AND fractional(newvtbi(st)/100)=0)) THEN big_step ELSE
                current_sv(st) ENDIF
        IN
          st WITH [newvtbi := state_UP_vtbi(s, newvtbi(st)),
                   current_sv := s,
                   device  := resetElapsed(device(st))]
   

 %%
  % @function fup_case_vtbitime_vttmode
  % @description  when inputting vtbi over time in vttmode
  % @param {presstime} d pressing of key which accelerates the step augments the vtbi
  % @param {per_fup} st
  % @returns {state} updates vtbi
  % @memberof module: alaris_th
%%    
fup_case_vtbitime_vttmode(d: presstime, st: (per_fup)): state =
   LET s: stepvol = 
            IF d=0 AND current_sv(st) = small_step AND
               ((newvtbi(st)<100 AND fractional(newvtbi(st)/10)=0) OR
                (newvtbi(st)>100 AND fractional(newvtbi(st)/100)=0)) THEN big_step ELSE
                current_sv(st) ENDIF,
       nv: ivols = state_UP_vtbi(s, newvtbi(st))
        IN
          st WITH [newvtbi := nv,
                   newrate := IF
                               newtime(st) = 0 THEN 0
			      ELSE nv / newtime(st)
                              ENDIF,
                   current_sv := s,
                   device  := resetElapsed(device(st))]

% Fast up chevron key associated with time to infuse

%%
  % @function state_UP_time
  % @description used by fup to increment time by step defined by the value of the time
  % @param {steptime} s
  % @param {itimes} v
  % @returns {irates} returns new value of time
%% 

  state_UP_time(s: steptime, v: itimes): itimes =
    trim_time(floor(v/s)*s + s)
    
  %%
  % @function fup_case_vtbitime_ttmode
  % @description  when inputting vtbi over time in ttmode
  % @param {presstime} d pressing of key which accelerates the step augments the time
  % @param {per_fup} st
  % @returns {state} updates times
  % @memberof module: alaris_th
%%     

  fup_case_vtbitime_ttmode(d: presstime, st: (per_fup)): state = 
  LET s: steptime = 
            COND d=4 -> 10*small_step,
                 d=3 -> 60,
                 ELSE -> 600
            ENDCOND,
      nt: itimes =  state_UP_time(s, newtime(st))
        IN
          st WITH [newtime := nt,
                   newrate := IF
                               nt = 0 THEN 0
			      ELSE newvtbi(st) / nt
                              ENDIF,
                   current_st := s,
                   device := resetElapsed(device(st))]

 %%
  % @function fup_case_dispvtbi_bagmode
  % @description  sets the bags menu cursor to maximum
  % @param {per_fup} st
  % @returns {state} also intialises elapsed time
  % @memberof module: alaris_th
%%     
    
  fup_case_dispvtbi_bagmode(st: (per_fup)): state = 
    st WITH [ bagscursor := mbags,
              device := resetElapsed(device(st)) ]

 %%
  % @function fup_case_dispvtbi_tbagmode
  % @description  sets the bags menu cursor (in vtbi over time) to maximum
  % @param {per_fup} st
  % @returns {state} also intialises elapsed time
  % @memberof module: alaris_th
%%  

  fup_case_dispvtbi_tbagmode(st: (per_fup)): state = 
    st WITH [ bagscursor := mbags,
              device := resetElapsed(device(st)) ]

% Fast up chevron key associated with the options menu
%%
  % @function fup_case_options
  % @description  sets the options menu cursor to zero
  % @param {per_fup} st
  % @returns {state} also intialises elapsed time
  % @memberof module: alaris_th
%%  

  fup_case_options(st: (per_fup)): state =
   st WITH [ qcursor := 0,
             device := resetElapsed(device(st)) ]

% Fast up chevron key
%%
  % @function fup
  % @description  deals with three cases relating to fup and infusion rate depending on conditions
  % @description deals with two cases relating to fup and vtbi depending on conditions
  % @description one case associated with time
  % @description two cases associated with bags (when updating vtbi and when updating vtbi over time
  % @description one option associated with the options menu
  % @param {per_fup} st
  % @returns {state}
  % @memberof module: alaris_th
%% 

  fup(st: (per_fup)): state =
         LET d: presstime = decrement(pressed(st), 1) IN
         (COND
           (topline(st) = holding OR topline(st) = setrate) & 
                NOT rlock(st) 
                   -> fup_case_holding_NOTrlock(d, st),
           (topline(st) = infusing) & 
                NOT rlock(st) 
                   -> fup_case_infusing_NOTrlock(d, st),
           (topline(st) = infusing OR topline(st) = holding OR topline(st) = setrate) & 
                    rlock(st)     
                   -> fup_case_infusingORholding_rlock(st),
           topline(st) = dispvtbi & entrymode(st) = vtmode                         
                   -> fup_case_dispvtbi_vtmode(d, st),
           topline(st) = vtbitime & entrymode(st) = vttmode                              
                   -> fup_case_vtbitime_vttmode(d, st),
           topline(st) = vtbitime & entrymode(st) = ttmode                                            
                   -> fup_case_vtbitime_ttmode(d, st),
           topline(st) = dispvtbi & entrymode(st) = bagmode                                           
                   -> fup_case_dispvtbi_bagmode(st),
           topline(st) = dispvtbi & entrymode(st) = tbagmode                                           
                   -> fup_case_dispvtbi_tbagmode(st),
           topline(st) = options                                             
                   -> fup_case_options(st)

        ENDCOND) WITH [pressed := d,
                      which_press := fupb]

% Slow up chevron key associated with infusion rate

%%
  % @function sup
  % @description  deals with three cases relating to sup and infusion rate depending on conditions
  % @description deals with two cases relating to sup and vtbi depending on conditions
  % @description one case associated with time
  % @description two cases associated with bags (when updating vtbi and when updating vtbi over time
  % @description one option associated with the options menu
  % @param {per_sup} st
  % @returns {state}
  % @memberof module: alaris_th
%% 

%%
  % @function state_up_rate
  % @description used by sup to increment rate by step defined by the value of the rate
  % @param {steprate} d
  % @param {irates} v
  % @returns {irates} returns new value of infusion rate
%% 

  state_up_rate(d: steprate, v: irates): irates = 
     IF    v < 100                 THEN trim_rate( floor((v*10) + d) / 10 )
     ELSIF v >= 100 AND v < 1000 THEN trim_rate( floor((v) + d) )
     ELSE                                 trim_rate( (floor(v/10) + d) * 10 ) ENDIF
  

%%
  % @function sup_case_holding_NOTrlock
  % @description  when pump holding and infusion rate not locked
   % @param {per_sup} st
  % @returns {state}
  % @memberof module: alaris_th
%%  
 sup_case_holding_NOTrlock(st: (per_sup)): state =
   LET v: irates = device(st)`infusionrate,
       r: irates = state_up_rate(small_step, v)
        IN
          st WITH [device := aug_rate(device(st), r),
                   topline := COND r = 0 -> setrate,
                                ELSE -> holding ENDCOND,
                   current_sr := small_step]

%%
  % @function sup_case_infusing_NOTrlock
  % @description  when pump infusing and infusion rate not locked
  % @param {per_sup} st
  % @returns {state}
  % @memberof module: alaris_th
%%   
sup_case_infusing_NOTrlock(st: (per_sup)): state =
   LET v: irates = device(st)`infusionrate,
       r: irates = state_up_rate(small_step, v)
        IN
          st WITH [device := aug_rate(device(st), r),
                   current_sr := small_step]

  %%
  % @function sup_case_infusingORholding_NOTrlock
  % @description  when pump infusing or holding and infusion rate locked
  % @param {per_sup} st
  % @returns {state} shows locked and amends the display
  % @memberof module: alaris_th
%%   

 sup_case_infusingORholding_rlock(st: (per_sup)): state =
    st WITH [ topline := locked,
	      middisp := LAMBDA(x: imid_type): FALSE,
              fndisp1 := fnull,
	      fndisp2 := fnull,
              fndisp3 := fnull,
              device := resetElapsed(device(st))]

 % Slow up chevron key associated with volume to be infused

 %%
  % @function state_up_vtbi
  % @description used by sup to increment vtbi by step defined by the value of the vtbi
  % @param {stepvol} d
  % @param {ivols} v
  % @returns {ivols} returns new value of vtbi
%% 

state_up_vtbi(d: stepvol, v: ivols): ivols = 
     IF    v < 100                 THEN trim_vtbi( floor((v*10) + d) / 10 )
     ELSIF v >= 100 AND v < 1000 THEN trim_vtbi( floor((v) + d) )
     ELSE                                 trim_vtbi( (floor(v/10) + d) * 10 ) ENDIF

 %%
  % @function sup_case_dispvtbi_vtmode
  % @description  when display vtbi in top line and in vtmode
  % @param {per_sup} st
  % @returns {state} updates vtbi
  % @memberof module: alaris_th
%%  

  
sup_case_dispvtbi_vtmode(st: (per_sup)): state =
          st WITH [newvtbi := state_up_vtbi(small_step, newvtbi(st)),
                   current_sv := small_step,
                   device  := resetElapsed(device(st))]

 %%
  % @function sup_case_vtbitime_vttmode
  % @description  when inputting vtbi over time in vttmode
  % @param {per_sup} st
  % @returns {state} updates temporary values vtbi and rate
  % @memberof module: alaris_th
%%   

 sup_case_vtbitime_vttmode(st: (per_sup)): state =
    LET nv: ivols = state_up_vtbi(small_step, newvtbi(st))
        IN
          st WITH [newvtbi := nv,
                   newrate := IF
                               newtime(st) = 0 THEN 0
			     ELSE nv / newtime(st)
                              ENDIF,
                   current_sv := small_step,
                   device  := resetElapsed(device(st))]

% Slow up chevron key associated with time to infuse

%%
  % @function state_up_time
  % @description used by sup to increment time by step defined by how long the chevron key has been pressed
  % @param {steptime} s
  % @param {itimes} v
  % @returns {irates} returns new value of time
%% 

  state_up_time(s: steptime, v: itimes): itimes = 
     trim_time(floor(v/s)*s + s)
   
 %%
  % @function sup_case_vtbitime_ttmode
  % @description  when inputting vtbi over time in ttmode
  % @param {presstime} d pressing of key which accelerates the step that augments the time
  % @param {per_sup} st
  % @returns {state} updates time
  % @memberof module: alaris_th
%% 

  sup_case_vtbitime_ttmode(d: presstime, st: {st: state | per_sup(st)}): state =
     LET s: steptime = 
            COND
              d=4 -> small_step,
              d=3 -> 10*small_step,
              d=2 -> 60,
              ELSE -> 600
             ENDCOND,
        nt: itimes = state_up_time(s, newtime(st))
        IN
          st WITH [newtime := nt,
                   newrate := IF
                               nt = 0 THEN 0
			      ELSE newvtbi(st) / nt
                              ENDIF,
                   current_st := small_step,
                   device  := resetElapsed(device(st))]
   
 %%
  % @function sup_case_dispvtbi_bagmode
  % @description  increments the bags menu cursor
  % @param {per_sup} st
  % @returns {state} also intialises elapsed time
  % @memberof module: alaris_th
%%    

 sup_case_dispvtbi_bagmode(st: (per_sup)): state =
    st WITH [ bagscursor := COND bagscursor(st) < mbags -> bagscursor(st) + 1,
                                 bagscursor(st) >= mbags -> bagscursor(st) ENDCOND,
              device := resetElapsed(device(st)) ]

 %%
  % @function sup_case_dispvtbi_tbagmode
  % @description  increments the bags menu cursor (in vtbi over time)
  % @param {per_sup} st
  % @returns {state} also intialises elapsed time
  % @memberof module: alaris_th
%%  

  sup_case_dispvtbi_tbagmode(st: (per_sup)): state =
    st WITH [ bagscursor := COND bagscursor(st) < mbags -> bagscursor(st) + 1,
                                 bagscursor(st) >= mbags -> bagscursor(st) ENDCOND,
              device := resetElapsed(device(st)) ]

% Slow up chevron key associated with the options menu

%%
  % @function sup_case_options
  % @description  decrements the options menu cursor
  % @param {per_sup} st
  % @returns {state} also intialises elapsed time
  % @memberof module: alaris_th
%%  

  sup_case_options(st: (per_sup)): state =
    st WITH [ qcursor := 
                IF qcursor(st) = 0 THEN 0
                ELSE qcursor(st) -1
                ENDIF,  
              device := resetElapsed(device(st)) ]

% Slow up chevron key
%%
  % @function sup
  % @description  deals with three cases relating to sup and infusion rate depending on conditions
  % @description deals with two cases relating to sup and vtbi depending on conditions
  % @description one case associated with time
  % @description two cases associated with bags (when updating vtbi and when updating vtbi over time
  % @description one option associated with the options menu
  % @param {per_sup} st
  % @returns {state}
  % @memberof module: alaris_th
%% 

  sup(st: (per_sup)): state =
      LET d: presstime = decrement(pressed(st), 1) IN 
        (COND
          (topline(st) = holding OR topline(st) = setrate) & 
            NOT rlock(st) 
               ->  sup_case_holding_NOTrlock(st),
           (topline(st) = infusing) & 
            NOT rlock(st) 
               ->  sup_case_infusing_NOTrlock(st),
          (topline(st) = infusing OR topline(st) = holding OR topline(st) = setrate)  & 
              rlock(st)     
               ->  sup_case_infusingORholding_rlock(st),
          (topline(st) = dispvtbi) & 
                (entrymode(st) = vtmode)                            
               ->  sup_case_dispvtbi_vtmode(st),
          (topline(st) = vtbitime) & 
             (entrymode(st) = vttmode)                                
               ->  sup_case_vtbitime_vttmode(st),
          (topline(st) = vtbitime) & 
                (entrymode(st) = ttmode)                                        
               ->  sup_case_vtbitime_ttmode(d, st),
          (topline(st) = dispvtbi) & 
            (entrymode(st) = bagmode)                                           
               ->  sup_case_dispvtbi_bagmode(st),
          (topline(st) = dispvtbi) & (entrymode(st) = tbagmode)                 
               ->  sup_case_dispvtbi_tbagmode(st),
          topline(st) = options                                               
               ->  sup_case_options(st)
        ENDCOND) WITH [pressed := d, which_press := supb]

% The fast down button associated with infusion rate
 %-- the conditions for DN are apparently slightly different from those of the other buttons...
%%
  % @function state_DN_rate
  % @description used by fdown to decrement rate by step defined by the value of the rate
  % @param {steprate} d
  % @param {irates} v
  % @returns {irates} returns new value of infusion rate
%% 

  state_DN_rate(d: steprate, v: irates): irates = 
     IF    v < 100                THEN trim_rate( ceil_rate(v) - d)
     ELSIF v >= 100 AND v < 1000  THEN trim_rate( (ceil_rate(v/10) - d) * 10 )
     ELSE                                 trim_rate( (ceil_rate(v/100) - d) * 100 ) ENDIF

%%
  % @function fdown
  % @description  deals with three cases relating to fdown and infusion rate depending on conditions
  % @description deals with two cases relating to fdown and vtbi depending on conditions
  % @description one case associated with time
  % @description two cases associated with bags (when updating vtbi and when updating vtbi over time
  % @description one option associated with the options menu
  % @param {presstime} d pressing of key which accelerates the step
  % @param {per_fdown} st
  % @returns {state}
  % @memberof module: alaris_th
%% 

%%
  % @function fdown_case_holding_NOTrlock
  % @description  when pump holding and infusion rate not locked
  % @param {presstime} d pressing of key which accelerates the step, decrements infusion rate
  % @param {per_fdown} st
  % @returns {state}
  % @memberof module: alaris_th
%%  
 fdown_case_holding_NOTrlock(d: presstime, st: (per_fdown)): state =
    LET v: irates = device(st)`infusionrate,
        s: steprate = 
            COND
              d=0 AND current_sr(st) = small_step AND
               ((v>10 AND v<100 AND fractional(v/10)=0) OR
                (v>100 AND fractional(v/100)=0)) -> big_step, 
              d/=maxpress AND current_sr(st) = big_step AND (v=10 OR v=100) -> small_step,
              ELSE ->  current_sr(st) ENDCOND,
        r: irates = state_DN_rate(s, v)
        IN
          st WITH [device := aug_rate(device(st), r),
                   topline := COND r = 0 -> setrate,
                                ELSE -> holding ENDCOND,
                   current_sr := s]

%%
  % @function fdown_case_infusing_NOTrlock
  % @description  when pump infusing and infusion rate not locked
  % @param {presstime} d pressing of key which accelerates the step decrements the infusion rate
  % @param {per_fdown} st
  % @returns {state}
  % @memberof module: alaris_th
%% 
  fdown_case_infusing_NOTrlock(d: presstime, st: (per_fdown)): state =
    LET v: irates = device(st)`infusionrate,
        s: steprate = 
            COND
              d=0 AND current_sr(st) = small_step AND
               ((v>10 AND v<100 AND fractional(v/10)=0) OR
                (v>100 AND fractional(v/100)=0)) -> big_step, 
              d/=maxpress AND current_sr(st) = big_step AND (v=10 OR v=100) -> small_step,
              ELSE ->  current_sr(st) ENDCOND,
        r: irates = state_DN_rate(s, v)
        IN
          st WITH [device := aug_rate(device(st), r),
                   current_sr := s]

  %%
  % @function fdown_case_infusingORholding_NOTrlock
  % @description  when pump infusing or holding and infusion rate locked
  % @param {per_fdown} st
  % @returns {state} shows locked and amends the display
  % @memberof module: alaris_th
%%   
 
 fdown_case_infusingORholding_rlock(st: (per_fdown)): state =
    st WITH [ topline := locked,
              middisp := LAMBDA(x: imid_type): FALSE,
              fndisp1 := fnull,
	      fndisp2 := fnull,
              fndisp3 := fnull,
              device  := resetElapsed(device(st)) ]

% The fast down button associated with volume to be infused
%%
  % @function state_DN_vtbi
  % @description used by fdown to decrement vtbi by step defined by the value of the vtbi
  % @param {stepvol} d
  % @param {ivols} v
  % @returns {ivols} returns new value of vtbi
%% 

   state_DN_vtbi(d: stepvol, v: ivols): ivols = 
     IF    v < 100                THEN trim_vtbi( ceil_vtbi(v) - d)
     ELSIF v >= 100 AND v < 1000  THEN trim_vtbi( (ceil_vtbi(v/10) - d) * 10 )
     ELSE                                 trim_vtbi( (ceil_vtbi(v/100) - d) * 100 ) ENDIF

 %%
  % @function fdown_case_dispvtbi_vtmode
  % @description  when display vtbi in top line and in vtmode
  % @param {presstime} d pressing of key which accelerates the step decreases the vtbi
  % @param {per_fdown} st
  % @returns {state} updates vtbi
  % @memberof module: alaris_th
%%  
 
fdown_case_dispvtbi_vtmode(d: presstime, st: (per_fdown)): state =
   LET s: stepvol = 
            COND
              d=0 AND current_sv(st) = small_step AND
               ((newvtbi(st)>10 AND newvtbi(st)<100 AND fractional(newvtbi(st)/10)=0) OR
                (newvtbi(st)>100 AND fractional(newvtbi(st)/100)=0)) -> big_step, 
              d/=maxpress AND current_sv(st) = big_step AND (newvtbi(st)=10 OR newvtbi(st)=100) -> small_step,
              ELSE ->  current_sv(st) ENDCOND
        IN
          st WITH [newvtbi := state_DN_vtbi(s, newvtbi(st)),
                   current_sv := s,
                   device  := resetElapsed(device(st))]

   
 %%
  % @function fdown_case_vtbitime_vttmode
  % @description  when inputting vtbi over time in vttmode
  % @param {presstime} d pressing of key which accelerates the step decreases the vtbi
  % @param {per_fdown} st
  % @returns {state} updates vtbi
  % @memberof module: alaris_th
%%    

  fdown_case_vtbitime_vttmode(d: presstime, st: (per_fdown)): state =
     LET s: stepvol = 
            COND
              d=0 AND current_sv(st) = small_step AND
               ((newvtbi(st)>10 AND newvtbi(st)<100 AND fractional(newvtbi(st)/10)=0) OR
                (newvtbi(st)>100 AND fractional(newvtbi(st)/100)=0)) -> big_step, 
              d/=maxpress AND current_sv(st) = big_step AND (newvtbi(st)=10 OR newvtbi(st)=100) -> small_step,
              ELSE ->  current_sv(st) ENDCOND,
          nv: ivols = state_DN_vtbi(s, newvtbi(st))
        IN
          st WITH [newvtbi := nv,
                   newrate := IF
                               newtime(st) = 0 THEN 0
			      ELSE nv / newtime(st)
                              ENDIF,
                   current_sv := s,
                   device  := resetElapsed(device(st))]

% The fast down button associated with time

%%
  % @function state_DN_time
  % @description used by fup to decrease time by step defined by the value of the time
  % @param {steptime} s
  % @param {itimes} v
  % @returns {itimes} returns new value of time
%% 

state_DN_time(s: steptime, v: itimes): itimes = 
     trim_time(ceiling(v/s)*s - s)

%%
  % @function state_dn_time
  % @description used by sdown to decrement time by step defined by how long the chevron key has been pressed
  % @param {steptime} s
  % @param {itimes} v
  % @returns {irates} returns new value of time
%%
state_dn_time(s: steptime, v: itimes): itimes = 
     trim_time(ceiling(v/s)*s - s)

  %%
  % @function fdown_case_vtbitime_ttmode
  % @description  when inputting vtbi over time in ttmode
  % @param {presstime} d pressing of key which accelerates the step decreases the time
  % @param {per_fdown} st
  % @returns {state} updates times
  % @memberof module: alaris_th
%%      
 fdown_case_vtbitime_ttmode(d: presstime, st: (per_fdown)): state =
   LET s: steptime = 
            COND
              d=4 -> 10*small_step,
              d=3 -> 60,
              ELSE -> 600
             ENDCOND,
         nt: itimes = state_DN_time(s, newtime(st))
        IN
          st WITH [newtime := nt,
                   newrate := IF
                               nt = 0 THEN 0
			     ELSE newvtbi(st) / nt
                              ENDIF,
                   current_st := s,
                   device  := resetElapsed(device(st))]


 %%
  % @function fdown_case_dispvtbi_bagmode
  % @description  sets the bags menu cursor to minimum
  % @param {per_fdown} st
  % @returns {state} also intialises elapsed time
  % @memberof module: alaris_th
%%     

  fdown_case_dispvtbi_bagmode(st: (per_fdown)): state =
   st WITH [ bagscursor := 0,
             device := resetElapsed(device(st)) ]
  
  %%
  % @function fdown_case_dispvtbi_tbagmode
  % @description  sets the bags menu cursor (in vtbi over time) to minimum
  % @param {per_fdown} st
  % @returns {state} also intialises elapsed time
  % @memberof module: alaris_th
%%  

 fdown_case_dispvtbi_tbagmode(st: (per_fdown)): state =
   st WITH [ bagscursor := 0,
             device := resetElapsed(device(st)) ]

% The fast down button associated with the options menu

%%
  % @function fdown_case_options
  % @description  sets the options menu cursor to max (depending on number of entries in menu)
  % @param {per_fdown} st
  % @returns {state} also intialises elapsed time
  % @memberof module: alaris_th
%%  

  fdown_case_options(st: (per_fdown)): state =
   st WITH [ qcursor := 
               COND device(st)`infusing? AND NOT rdisabled(st) AND 
                        rlock(st) -> 3,
                    device(st)`infusing? AND NOT rdisabled(st) AND
                        NOT rlock(st) -> 3,
                    device(st)`infusing? AND rdisabled(st) -> 2,
                    NOT device(st)`infusing? AND rdisabled(st)  -> 5,
                    ELSE -> dpdtls
               ENDCOND,
             device  := resetElapsed(device(st)) ]

% The general fast down button

 % Fast down chevron key
%%
  % @function fdown
  % @description  deals with three cases relating to fdown and infusion rate depending on conditions
  % @description deals with two cases relating to fdown and vtbi depending on conditions
  % @description one case associated with time
  % @description two cases associated with bags (when updating vtbi and when updating vtbi over time
  % @description one option associated with the options menu
  % @param {per_fdown} st
  % @returns {state}
  % @memberof module: alaris_th
%% 

 fdown(st: (per_fdown)): state =
        LET d: presstime = decrement(pressed(st), 1) IN
        (COND
          ((topline(st)=holding) OR (topline(st)=setrate)) & 
                   NOT rlock(st) 
               -> fdown_case_holding_NOTrlock(d, st),
          (topline(st) = infusing) & 
                   NOT rlock(st) 
               -> fdown_case_infusing_NOTrlock(d, st),
          ((topline(st) = infusing) OR (topline(st)=holding) OR 
               (topline(st)=setrate)) & rlock(st)     
               -> fdown_case_infusingORholding_rlock(st),
          (topline(st) = dispvtbi) & (entrymode(st) = vtmode)                   
               -> fdown_case_dispvtbi_vtmode(d, st),
          (topline(st) = vtbitime) & (entrymode(st) = vttmode)                 
               -> fdown_case_vtbitime_vttmode(d, st),
          (topline(st) = vtbitime) & (entrymode(st) = ttmode)                   
               -> fdown_case_vtbitime_ttmode(d, st),
          (topline(st) = dispvtbi) & (entrymode(st) = bagmode)                  
               -> fdown_case_dispvtbi_bagmode(st),
          (topline(st) = dispvtbi) & (entrymode(st) = tbagmode)                
               -> fdown_case_dispvtbi_tbagmode(st),
          topline(st) = options                                               
               -> fdown_case_options(st)
       ENDCOND) WITH [pressed := d,
                      which_press := fdownb]

% The slow down button associated with infusion rate

%%
  % @function sdown
  % @description  deals with three cases relating to sdown and infusion rate depending on conditions
  % @description deals with two cases relating to sdown and vtbi depending on conditions
  % @description one case associated with time
  % @description two cases associated with bags (when updating vtbi and when updating vtbi over time
  % @description one option associated with the options menu
  % @param {per_sdown} st
  % @returns {state}
  % @memberof module: alaris_th
%% 

%%
  % @function state_dn_rate
  % @description used by sdown to decrement rate by step defined by the value of the rate
  % @param {steprate} d
  % @param {irates} v
  % @returns {irates} returns new value of infusion rate
%% 

 %-- note: dn(100) = 99 (and not 99.9)
  state_dn_rate(d: steprate, v: irates): irates = 
     IF    v < 100                THEN trim_rate( (ceil_rate(v*10) - d) / 10 )
     ELSIF v >= 100 AND v < 1000  THEN trim_rate( ceil_rate(v - d) )
     ELSE                                 trim_rate( (ceil_rate(v/10) - d) * 10 ) ENDIF

%%
  % @function sdown_case_holding_NOTrlock
  % @description  when pump holding and infusion rate not locked
   % @param {per_sdown} st
  % @returns {state}
  % @memberof module: alaris_th
%%  
  
sdown_case_holding_NOTrlock(st: (per_sdown)): state =
    LET v: irates = device(st)`infusionrate,
        r: irates = state_dn_rate(small_step, v)
        IN
          st WITH [device := aug_rate(device(st), r),
                   topline := COND r = 0 -> setrate,
                                   ELSE -> holding ENDCOND,
                   current_sr := small_step]

%%
  % @function sdown_case_infusing_NOTrlock
  % @description  when pump infusing and infusion rate not locked
  % @param {per_sdown} st
  % @returns {state}
  % @memberof module: alaris_th
%%   

  sdown_case_infusing_NOTrlock(st: (per_sdown)): state =
    LET v: irates = device(st)`infusionrate,
        r: irates = state_dn_rate(small_step, v)
        IN
          st WITH [device := aug_rate(device(st), r),
                   current_sr := small_step]

  %%
  % @function sdown_case_infusingORholding_NOTrlock
  % @description  when pump infusing or holding and infusion rate locked
  % @param {per_sdown} st
  % @returns {state} shows locked and amends the display
  % @memberof module: alaris_th
%%   

  sdown_case_infusingORholding_rlock(st: (per_sdown)): state =
   st WITH [ topline := locked,
             middisp := LAMBDA(x: imid_type): FALSE,
             fndisp1 := fnull,
	     fndisp2 := fnull,
             fndisp3 := fnull,
             device   := resetElapsed(device(st)) ]

% The slow down button associated with volume to be infused
%-- note: dn(100) = 99 (and not 99.9)

%%
  % @function state_dn_vtbi
  % @description used by sdown to decrement vtbi by step defined by the value of the vtbi
  % @param {stepvol} d
  % @param {ivols} v
  % @returns {ivols} returns new value of vtbi
%% 

  state_dn_vtbi(d: stepvol, v: ivols): ivols = 
     IF    v < 100                THEN trim_vtbi( (ceil_vtbi(v*10) - d) / 10 )
     ELSIF v >= 100 AND v < 1000  THEN trim_vtbi( ceil_vtbi(v - d) )
     ELSE                                 trim_vtbi( (ceil_vtbi(v/10) - d) * 10 ) ENDIF

 %%
  % @function sdown_case_dispvtbi_vtmode
  % @description  when display vtbi in top line and in vtmode
  % @param {per_sdown} st
  % @returns {state} updates vtbi
  % @memberof module: alaris_th
%%  

  sdown_case_dispvtbi_vtmode(st: (per_sdown)): state =
          st WITH [newvtbi := state_dn_vtbi(small_step, newvtbi(st)),
                   current_sv := small_step,
                   device  := resetElapsed(device(st))]

 %%
  % @function sdown_case_vtbitime_vttmode
  % @description  when inputting vtbi over time in vttmode
  % @param {per_sup} st
  % @returns {state} updates temporary values vtbi and rate
  % @memberof module: alaris_th
%%

 sdown_case_vtbitime_vttmode(st: (per_sdown)): state =
    LET nv: ivols = state_dn_vtbi(small_step, newvtbi(st))
        IN
          st WITH [newvtbi := nv,
                   newrate := IF
                               newtime(st) = 0 THEN 0
			      ELSE nv / newtime(st)
                              ENDIF,
                   current_sv := small_step,
                   device  := resetElapsed(device(st))]

% The slow down button associated with time
 %%
  % @function sdown_case_vtbitime_ttmode
  % @description  when inputting vtbi over time in ttmode
  % @param {presstime} d pressing of key which accelerates the step that decreases the time
  % @param {per_sdown} st
  % @returns {state} updates time
  % @memberof module: alaris_th
%% 

  sdown_case_vtbitime_ttmode(d: presstime, st: (per_sdown)): state =
    LET s: steptime = 
            COND
              d=4 -> small_step,
              d=3 -> 10*small_step,
              d=2 -> 60,
              ELSE -> 600
             ENDCOND,
        nt: itimes = state_dn_time(s, newtime(st))
        IN
          st WITH [newtime := nt,
                   newrate := IF
                               nt = 0 THEN 0
			      ELSE newvtbi(st) / nt
                              ENDIF,
                   current_st := s,
                   device  := resetElapsed(device(st))]

 %%
  % @function sdown_case_dispvtbi_bagmode
  % @description  decrements the bags menu cursor
  % @param {per_sdown} st
  % @returns {state} also intialises elapsed time
  % @memberof module: alaris_th
%%    
  
sdown_case_dispvtbi_bagmode(st: (per_sdown)): state =
   st WITH [ bagscursor := COND bagscursor(st) > 0 -> bagscursor(st) - 1,
                                bagscursor(st) = 0 -> bagscursor(st) ENDCOND,
             device := resetElapsed(device(st)) ]

%%
  % @function sdown_case_dispvtbi_tbagmode
  % @description  decrements the bags menu cursor (in vtbi over time)
  % @param {per_sdown} st
  % @returns {state} also intialises elapsed time
  % @memberof module: alaris_th
%%  
 
 sdown_case_dispvtbi_tbagmode(st: (per_sdown)): state =
   st WITH [ bagscursor := COND bagscursor(st) > 0 -> bagscursor(st) - 1,
                                bagscursor(st) = 0 -> bagscursor(st) ENDCOND,
             device := resetElapsed(device(st)) ]

% The slow down button associated with options menu

%%
  % @function sdown_case_options
  % @description  decrements the options menu cursor
  % @param {per_sdown} st
  % @returns {state} also intialises elapsed time
  % @memberof module: alaris_th
%%  

  sdown_case_options(st: (per_sdown)): state =
   st WITH [ qcursor := COND 
                          qcursor(st) = dpdtls -> qcursor(st),
                          qcursor(st) < dpdtls AND 
                             (optionsmenu(st)(qcursor(st)+1) = optionblank)  -> qcursor(st),
                             ELSE -> qcursor(st)+1 ENDCOND,
              device := resetElapsed(device(st)) ]

% The general slow down function

%%
  % @function sdown
  % @description  deals with three cases relating to sdown and infusion rate depending on conditions
  % @description deals with two cases relating to sdown and vtbi depending on conditions
  % @description one case associated with time
  % @description two cases associated with bags (when updating vtbi and when updating vtbi over time
  % @description one option associated with the options menu
  % @param {per_sdown} st
  % @returns {state}
  % @memberof module: alaris_th
%% 


  sdown(st: (per_sdown)): state =
       LET d: presstime = decrement(pressed(st), 1) IN
        (COND
         ((topline(st) = holding) OR (topline(st) = setrate)) & 
               NOT rlock(st) 
               -> sdown_case_holding_NOTrlock(st),
         (topline(st) = infusing) & 
               NOT rlock(st) 
               -> sdown_case_infusing_NOTrlock(st),
         ((topline(st) = infusing) OR (topline(st) = holding) OR (topline(st) = setrate)) & 
                   rlock(st)     
               -> sdown_case_infusingORholding_rlock(st),
         (topline(st) = dispvtbi) & (entrymode(st) = vtmode)                            
               -> sdown_case_dispvtbi_vtmode(st),
         (topline(st) = vtbitime) & (entrymode(st) = vttmode)                               
               -> sdown_case_vtbitime_vttmode(st),
         (topline(st) = vtbitime) & (entrymode(st) = ttmode)                                              
               -> sdown_case_vtbitime_ttmode(d, st),
	 (topline(st) = dispvtbi) & (entrymode(st) = bagmode)                                             
               -> sdown_case_dispvtbi_bagmode(st),
         (topline(st) = dispvtbi) & (entrymode(st) = tbagmode)                                             
               -> sdown_case_dispvtbi_tbagmode(st),
         (topline(st) = options)                                               
               -> sdown_case_options(st)
	ENDCOND) WITH [pressed := d,
                       which_press := sdownb]
  
 % Releasing the chevron keys

%%
  % @function per_release_chevron
  % @description general permission for releasing chevron key
  % @param {state} st
  % @returns {bool} 
  % @memberof module: alaris_th
%%

 per_release_chevron(st: state): boolean =
            per_chevron(st) OR (topline(st) = locked AND 
                   ((entrymode(st) = rmode) OR (entrymode(st) = infusemode)) AND
                   rlock(st))

%%
  % @function per_release_fup
  % @description specific permission for releasing fup key
  % @param {state} st
  % @returns {bool} 
  % @memberof module: alaris_th
%%

 per_release_fup(st: state): boolean = 
      which_press(st) = fupb AND pressed(st) < maxpress AND per_release_chevron(st)

%%
  % @function release_fup
  % @description invokes release key
  % @param {state} st
  % @returns {state} 
  % @memberof module: alaris_th
%%
 release_fup(st:(per_release_fup)): state =
     release_key(st)

%%
  % @function per_release_sup
  % @description specific permission for releasing fup key
  % @param {state} st
  % @returns {bool} 
  % @memberof module: alaris_th
%%

 per_release_sup(st: state): boolean = 
      which_press(st) = supb AND pressed(st) < maxpress AND per_release_chevron(st)

%%
  % @function release_sup
  % @description invokes release key
  % @param {state} st
  % @returns {state} 
  % @memberof module: alaris_th
%%

 release_sup(st:(per_release_sup)): state =
     release_key(st)


%%
  % @function per_release_fdown
  % @description specific permission for releasing fdown key
  % @param {state} st
  % @returns {bool} 
  % @memberof module: alaris_th
%%

 per_release_fdown(st: state): boolean = 
      which_press(st) = fdownb AND pressed(st) < maxpress AND per_release_chevron(st)

%%
  % @function release_fdown
  % @description invokes release key
  % @param {state} st
  % @returns {state} 
  % @memberof module: alaris_th
%%

 release_fdown(st:(per_release_fdown)): state =
     release_key(st)

%%
  % @function per_release_sdown
  % @description specific permission for releasing sdown key
  % @param {state} st
  % @returns {bool} 
  % @memberof module: alaris_th
%%

per_release_sdown(st: state): boolean = 
      which_press(st) = sdownb AND pressed(st) < maxpress AND per_release_chevron(st)

%%
  % @function release_sdown
  % @description invokes release key
  % @param {state} st
  % @returns {state} 
  % @memberof module: alaris_th
%%

 release_sdown(st:(per_release_sdown)): state =
     release_key(st)

%--- General theorems used in the analysis

%%
% @lemma check_chev_sup_permission
% @description permitted to release, if chevron key pressed
% @yelds QED
% @stats Runtime 96.53 secs. 18/7/17
%%

check_chev_sup_permission: LEMMA
 FORALL (st: state):
      per_sup(st) IMPLIES per_release_sup(sup(st))
%%
% @lemma check_chev_fup_permission
% @description permitted to release, if chevron key pressed
% @yelds QED
% @stats Run time  = 321.59 secs. 18/7/17
%%

check_chev_fup_permission: LEMMA
   FORALL (st: state):
      per_fup(st) IMPLIES per_release_fup(fup(st))

%%
% @lemma check_chev_sdown_permission
% @description permitted to release, if chevron key pressed
% @yelds QED
% @stats Run time  = 100.36 secs. 18/7/17
%%

check_chev_sdown_permission: LEMMA
   FORALL (st: state):
      per_sdown(st) IMPLIES per_release_sdown(sdown(st))

%%
% @lemma check_chev_fdown_permission
% @description permitted to release, if chevron key pressed
% @yelds QED
% @stats Run time  = 568.48 secs. 18/7/17
%%

check_chev_fdown_permission: LEMMA
   FORALL (st: state):
      per_fdown(st) IMPLIES per_release_fdown(fdown(st))

 END alaris_th
